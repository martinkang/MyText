# CPU 스케줄링
* 운영체제는 CPU 스케줄링을 통해 CPU 를 프로세스 간에 교환함으로써 컴퓨터를 보다 생산적으로 만든다.

## 5.1 기본개념
* 다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 데 있다.
	- 어떤 프로세스가 대기하게 되면 ( I/O 요청등에 의해 ), 
	운영체제는 CPU 를 그 프로세스로부터 회수해 다른 프로세스에 할당한다.
	- 거의 모든 컴퓨터 자원은 사용되기 전에 스케줄 된다.

### 5.1.1 CPU-입출력 버스트 사이클 ( CPU-I/O Burst Cycle )
* 프로세스의 실행은 CPU 실행과 입출력 대기의 사이클로 구성된다. 프로세스들은 이들 두 상태 사이를 교대로 왔다 갔다 한다.
	- CPU Burst
		- CPU 가 실행되는 시간
	- I/O Burst
		- 입출력을 대기하는 시간

##### CPU 와 입출력 버스트의 교차
![5.1](http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling_files/image002.jpg)   
-출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling.htm


### 5.1.2 CPU 스케줄러
* CPU 가 유휴 상태가 될 때마다 운영체제는 준비완료 큐에 있는 프로세스들 중에서 실행될 프로세스를 선택해야 한다.
	- 선택 절차는 단기 스케줄러에 의해 실행된다.
	- 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스들 중에서 선택하여 이들 중 하나에게 CPU 를 할당.
	- 스케줄러에 있는 레코드들은 일반적으로 프레스스들의 PCB 이다.


### 5.1.3 선점 스케줄링 ( Preemptive Scheduling )
* CPU 스케줄링은 다음의 네 가지 상황 하에서 발생할 수 있다.
	1. 한 프로세스가 실행 상태에서 대기  상태로 전환될 때 ( 입출력 호출이나 자식 process 를 wait 할 때 )
	2. 프로세스가 실행 상태에서 준비 완료 상태로 전황될 때 ( 인터럽트가 발생 )
	3. 프로세스가 대기 상태에서 준비완료 상태로 전환될 때 ( 입출력 종료 시 )
	4. 프로세스가 종료할 때
* 1 과 4 는 선택의 여지가 없이 준비완료 큐에 있는 새로운 프로세스를 반드시 선택해야 한다.
	- 비선점 방식 / 협조적 이라고 한다.
#### 용어
* 선점 스케줄링 ( Preemptive )
	- 한 프로세스가 CPU 를 점유했을 때, 또 다른 프로세스가 이 CPU 를 강제로 가져와서 점유할 수 있도록 하는 방식
	- 공유 자료에 접근했을 때 문제를 야기시킬 수 있다.
		- 한 프로세스가 자료를 변경하는 동안 선점되어 두 번째 프로세스가 실행 가능하게 되었다. 
	이 때 이 프로세스가 첫 번째 프로세스가 수정하던 비일관적인 상태에 있는 자료를 읽으려 할 수 있다.
		- 따라서 이런 접근을 조정할 방법이 필요하며 비용이 발생한다.
* 비선점 스케줄링 ( Non-Preemptive )
	- CPU 가 한 프로세스에 할당되면, 프로세스가 종료하든지 대기 상태로 전환해 CPU 방출 할때까지 CPU 를 점유하는 방식.
	- 프로세스간 오버헤드가 적지만, 대화식 시분할 시스템에 적합하지 않다.
	- 하나의 긴 작업을 모든 프로세스가 계속 기다릴 수 있다.
	- Timer 와 같은 특수 하드웨어를 요구하지 않기 때문에 특정 기종에서 채택될 수 있다.


### 5.1.4 디스패처 ( Dispatcher )
* CPU 의 제어를 단기 스케줄러가 선택한 프로세스에게 주는 모듈
	* 하는 일
		- Context Switching
		- 사용자 모드로 전환하는 일
		- 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동 하는 일
* 디스패처는 모든 프로세스의 문맥 교환 ( Context Switching ) 시에 호출되므로, 가능한 한 빨라야 한다.

#### 용어
* 디스패치 지연 ( dispatch latency )
	- 디스패처가 하나의 프로세스를 중단시키고 다른 프로세스를 실행시키는 데까지 소요되는 시간


## 5.2 스케줄링 기준
* 서로 다른 CPU 스케줄링 알고리즘은 다른 특성을 가지고 있다.
	- 특정 상황에서 어떤 알고리즘을 선택하려면, 다양한 알고리즘들의 서로 다른 특성을 반드시 고려해야 한다.
* CPU 스케줄링 알고리즘을 비교하기 위해 사용되는 기준
	- CPU 이용률 ( utilization )
	- 처리량 ( throughput )
		- 단위 시간당 완료된 프로세스의 개수
	- 총처리 시간 ( turnaround time )
		- 프로세스의 제출 시간과 완료 시간의 간격
	- 대기 시간 ( waiting time )
	- 응답 시간 ( response time )
		- 하나의 요구를 제출한 후 첫 번째 응답이 나올 때 까지의 시간
		- Interactive System 에서 중요한 기준이 된다.


## 5.3 스케줄링 알고리즘

### 5.3.1 선입 선처리 스케줄링 ( First Come, First Served Scheduling : FCFS )
* CPU 를 먼저 요청하는 프로세스가 CPU 를 먼저 할당 받는다.
	- FIFO 큐로 관리
	- 비선점형 방식
* 절차
	- 프로세스가 준비 완료 큐에 진입하면, 이 프로세스의 PCB 를 큐의 끝에 연결한다.
	- CPU 가 자유상태가 되면, 준비완료 큐의 앞부분에 있는 프로세스에게 할당된다.
	- 이 실행중인 프로세스는 이어 준비완료 큐에서 제거된다.
* 단점
	- 평균 대기 시간은 종종 대단히 길 수 있다.
* ex )
	- P1 : 20 ms, P2 : 1 ms, P3 1 ms
	- P1, P2, P3 순으로 도착할 때 FCFS 평균 대기시간 = ( 0 + 20 + 21 ) / 3 = 41 / 3
	- P2, P3, P1 순으로 도착할 때 FCFS 평균 대기시간 = ( 0 + 1 + 1 ) / 3 = 2 / 3

##### Gantt 차트
![5.2](http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling_files/image004.gif)  
-출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling.htm

#### 용어
* 호위효과 ( Convoy Effect )
	- 모든 다른 프로세스들이 하나의 긴 프로세스가 CPU 를 양도하기 기다림


### 5.3.2 최단 작업 우선 스케줄링 ( Shortest Job First Scheduling : SJF )
* CPU 가 이용 가능해지면 CPU Burst 가 가장 작은 프로세스에게 할당.
	- 실제적으로 단기 CPU 스케줄링 상에선 구현이 어려운데, 이는 실제 CPU Burst 길이를 알 수 없기 때문
		- CPU Burst 를 이전 CPU Burst 들과 비슷하다고 가정하고 스케줄링
* 선점형/비선점형 모두 가능
	- 선점형일 경우 새로운 프로세스가 현재 실행하고 있는 프로세스의 남은 시간보다 더 짧은 CPU 버스트를 가질 경우,
	선점형 SJF 알고리즘은 현재 실행하는 프로세스를 선점할 것이다.
* ex )
	* 스케줄링 예제
		- P1 도착시간 0, 버스트 시간 8
		- P2 도착시간 1, 버스트 시간 4
		- P3 도착시간 2, 버스트 시간 9
		- P4 도착시간 3, 버스트 시간 5
	* 


### 5.3.3 우선순위 알고리즘 ( Priority Scheduling )
* CPU 는 가장 높은 우선운위를 가진 프로세스에게 할당
* 우선순위는 내부적/ 외부적으로 정의될 수 있다.
* 선점형/비선점형 모두 가능
	- 선점형일 경우 실행중인 프로세스보다 높은 우선운위 프로세스가 나타나면 새로운 프로세스가 CPU 를 점유한다.
* 단점
	- 선점형 우선순위 알고리즘의 경우, 낮은 우선순위 프로세스들이 CPU 를 무기한 대기하는 경우가 발생

#### 용어
* 노화 ( aging )
	- 오랜 시간 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다.
	- 선점형 우선순위 알고리즘에서, 낮은 우선순위 프로세스들이 CPU 를 무기한 대기하는 걸 방지하기 위한 방법


### 5.3.4 라운드 로빈 스케줄링 ( Round Robin Scheduling )



### 5.3.5 다단계 큐 스케줄링 ( Multilevel Queue Scheduling )



### 5.3.6 다단계 피드백 큐 스케줄링 ( Multilevel Feedback Queue Scheduling )



## 5.4 스레드 스케줄링

## 5.5 다중 처리기 스케줄링
