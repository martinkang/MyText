# 다중 스레드 프로그래밍

## 4.1 개요 ( Overview )
* 스레드 ( Thread )
	- CPU 이용의 기본 단위
	- 구성
		- 스레드 ID
		- 프로그램 카운터
		- 레지스터 집합
		- 스택
	* 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 Signal 같은
	운영체제 자원들을 공유한다.
* 중량 프로세스 ( Heavyweight Process )
	- 전통적인 프로세스 개념으로 단일 제어 스레드를 가지고 있다.
		- 완전한 독립적 개체

##### 단일 및 다중 스레드 프로세스
![4.1](http://www.cs.odu.edu/~cs471w/spring11/lectures/threads_files/image012.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/threads.htm


### 4.1.2 장점
* 응답성
	- 대화영 어플리케이션을 다중 스레드화 하면 응용 프로그램의 일부분이 봉쇄되거나,
	다른 어플리케이션이 긴 작업을 실행하더라도 사용자에 대한 응답성이 좋다.
* 자원 공유
	- 스레드는 자동적으로 그들이 속한 프로세스의 자원들과 메모리를 공유.
		- 프로세스는 공유 메모리 또는 메시지 전달 기법을 통해야만 자원 공유가 가능
* 경제성
	- 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에 프로세스를 생성하고 Context Switching 하는 것보다
	경제적이다.
* 규모 가변성
	- 다중 처리기 구조에서 각각의 스레드가 다른 처리기에서 병렬로 실행될 수 있다.
		- 단일 스레드 프로세스는 처리기가 아무리 많더라도 오직 한 처리기에서만 실행 가능

##### 다중 스레드화 된 서버 구조
![4.2](http://www.cs.odu.edu/~cs471w/spring11/lectures/threads_files/image013.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/threads.htm


### 4.1.3 다중 코어 프로그래밍
* 시스템 설계에 있어서 최근의 경향은 하나의 칩 안에 여러 계산 코어를 넣는 것.
	- 각 코어는 운영체제에게는 독립된 처리기로 보인다.
	- 하나의 코어는 한 번에 오직 하나의 스레드만 실행할 수 있다.
* 다중코어 시스템 상에서 프로그래밍 하기 위해서는 다음과 같은 도전 과제가 있다.
	- 작업 나누기
		- 각 태스크가 개별 코어 상에서 병렬적으로 실행될 수 있도록 어플리케이션을
		독립된 병행가능 태스크로 나누는 져야 한다.
	- 균형
		- 전체 작업에 균등한 기여도를 가지도록 태스크를 나누져야 한다.
	- 데이터 분리
		- 태스크가 접근하고 조작하는 데이터 또한 개별 코어에서 사용할 수 있도록 나눠져야 한다.
	- 데이터 종속성
		- 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다.
	- 시험 및 디버깅
		- 프로그램이 다중코어세서 병렬로 실행될 대 다양한 실행 경로가 존재한다.
		이런 병행 프로그램을 시험하고 디버깅 하는 것은 매우 어렵다.

##### 단일 코어 시스템에서의 병행 실행
![4.3](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/chap4-singlecore2.png)

##### 다중코어 시스템에서의 병렬 실행
![4.4](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/chap4-multicore2.png)


## 4.2 다중 스레드 모델
* 사용자 스레드 ( user thread )
	- 커널은 스레드의 존재를 모르기 때문에, 유저 모드에서 커널 모드로의 전환이 필요없다.
		- 성능이 좋다.
	- 사용자 스레드는 커널이 스레드의 존재를 모르므로 스레드 단위 스케줄이 안된다.
	* Context switching 및 thread scheduling 에서 낮은 오버헤드를 가지지만 실행 중 blocking 당하면
	전체 프로세스가 다 같이 blocking 되며, 멀티프로세스의 지원을 받을 수 없다.
* 커널 스레드 ( kernel thread )
	- 스레드 지원을 커널 수준에서 제공, 스레드 각각의 상태와 Context 저장 가능
	- 하나의 스레드가 blocking 당해도 다른 스레드는 blocking 당하지 않으며 스레드 단위로 프로세서에 할당 가능하다.
	- 스레드 전환이 발생하면 커널이 참여하고, 커널 메모리를 사용하여 오버헤드가 발생한다.

### 4.2.1 다대일 모델 ( Many to One Model )
* 많은 사용자 수준 스레드를 하나의 커널 스레드로 사상.
	- 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 행해진다.
	- 한 스레드가 Blocking 당하면 전체 스레드가 Blocking 당한다.
	- 한 번에 하나의 스레드만이 커널에 접근할 수 있기 때문에 다중 스레드가 다중 처리기에서 돌아도
	병렬도 작동할 수 없다.

##### 다대일 모델
![4.5](http://www.cs.odu.edu/~cs471w/spring11/lectures/threads_files/image014.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/threads.htm


### 4.2.2 일대일 모델 ( One to One Model )
* 각 사용자 스레드를 각각 하나의 커널 스레드로 사상.
	- 하나의 스레드가 봉쇄적 시스템을 호출하더라도 다른 스레드가 실행될 수 있다.
	- 다중 처리기에서 다중 스레드가 병렬로 실행되는 것을 허용. 더 많은 병렬성을 제공
	- 단점
		- 사용자 수준 스레드를 생성할 대 그에 따른 컨러 스레드를 생성해야 하는데, 
		커널 스레드를 생성하는 오버헤드가 성능 저하를 야기시킬 수 있다.
		- 따라서 이 모델의 대부분 구현은 시스템에 의해서 지원되는 스레드 수를 제한

##### 일대일 모델
![4.6](http://www.cs.odu.edu/~cs471w/spring11/lectures/threads_files/image015.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/threads.htm


### 4.2.3 다대다 모델 ( Many to Many Model )
* 다수의 사용자 수준 스레드를 그보다 작은 수 혹은, 같은 수의 커널 스레드로 멀티 플렉스 한다.
	- 커널 스레드의 수는 응용 프로그램이나 특정 기계에 따라 결정된다.
* 개발자가 원하는 만큼의 사용자 수준 스레드를 만들도록 허용되지만, 한 번에 하나의 스레드만이 커널에
의해서 스케줄되기 때문에 진정한 동시성을 획들할 수는 없다.
* 필요한 만큼 사용자 스레드를 만들 수 있고, 그에 상응하는 커널 스레드가 다중 처리기에서 병렬 처리가 가능하다.

##### 다대다 모델
![4.7](http://www.cs.odu.edu/~cs471w/spring11/lectures/threads_files/image016.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/threads.htm

##### 두 수준 모델
![4.8](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/chap4-two-level-model2.png)


## 4.4 스레드와 관련된 문제들
* 다중 스레드 프로그램에서 고려해야할 몇몇 문제들에 대해 논의한다.


### 4.4.1 Fork() 및 Exec() 시스템 호출
* 만약 한 프로그램의 스레드가 fork() 를 호출하면 새로운 프로세스는 모든 스레드를 복제해야 하는가?
아니면 한 개의 스레드만 가지는 프로세스여야 하는가?
	- 몇몇 UNIX 기종은 두 가지 버전 fork() 를 모두 제공
	- 응용 프로그램에 따라 사용처가 다르다.
		- 만약 fork() 를 부르자마자 다시 exec() 를 호출하면, 모든 스레드를 다 복제할 필요가 없다.
			- 이 경우에는 fork() 시스템 호출을 한 스레드만 복사해 주는 것이 적절


### 4.4.2 스레드 취소
* 스레드가 끝나기 전에 그것을 강제 종료시키는 작업
	- ex ) 데이터베이스를 병렬로 검색하고 있다가 한 스레드가 결과를 찾았다면 나머지는 취소해도 된다.
* 목적 스레드의 취소는 다음과 같은 두가지 방식으로 발생 가능
	- 비동기식 취소
		- 한 스레드가 목적 스레드를 즉시 강제 종료
	- 지연 취소
		- 목적 스레드가 주기적으로 자신이 강제 종료 해야 하는 지를 검사.
		- 취소점 ( cancellation point )
			- 지연 취소에서 스레드들이 자신이 취소되어도 안전하다고 판단되는 시점에서 취소하는데 이 지점을 뜻함.
* 스레드 취소에서 문제점
	- 자원 할당 문제
		- 비동기식 취소가 발생한 경우 모든 시스템 자원을 다 회수하지 못할 수 있다.
	- 한 스레드가 공유하는 자료구조를 갱신하다가 취소 요청이 왔을 때.

#### 용어
* 목적 스레드 ( target thread )
	- 취소되어야 할 스레드


### 4.4.3 Signal Handling
* Signal 은 UNIX 에서 프로세스에게 어떤 사건이 일어났음을 알려주기 위해 사용된다.
	- 신호( Signal )는 특정 사건이 일어나야 생성된다.
	- 신호가 생성되면 프로세스에게 전달된다.
	- 신호가 전달되면 반드시 처리되어야 한다.

#### 단일 처리기에서는 신호는 항상 프로세스에게 전달되지만,	다중 처리기에서는 어느 스레드에 전달되어야 할까?
* 다음과 같은 선택이 존재.
	- 신호가 적용될 스레드에게 전달된다.
	- 모든 스레드에게 전달된다.
	- 몇몇 스레드들에게만 선택적으로 전달한다.
	- 특정 스레드가 모든 신호를 전달받도록 지정한다.
* 신호가 어디로 전달될지는 신호의 유형에 따라 다르다.
	* 동기식 신호
		- 불법적인 메모리 접근, 0 으로 나누기
		- 동기식 신호는 그 신호를 야기한 스레드에게 전달되어야 하고 다른 스레드에 전달되면 안된다.
	* 비동기식 신호
		- 신호가 실행 중인 프로세스 외부에서 생성 ( ex ) Control + C 
		- 비동기식 신호는 통상 다른 프로세스에 전달된다.

#### 용어
* 디폴트 신호 처리기
	- 모든 신호마다 커널에 의해 실행되는 신호에 대한 기본적인 처리 방법을 정의.
* 사용자 정의 처리기
	- 사용자가 정의한 처리 방식으로 디폴트 처리기를 대체할 수 있다.
	
#### APC ( Asynchronous Procedure Calls )
* Windows 에서 Signal 을 명시적으로 지원하지 않지만 APC 를 이용하여 이를 대리실행 할 수 있다.
* APC 는 사용자 스레드들이 특정 사건의 발생을 전달 받았을 때 호출될 함수를 지정할 수 있게 한다.


### 4.4.4 Thread pools
* 프로세스를 시작할 대 아예 일정한 수의 스레드들을 미리 풀로 만들어 두어
평소에는 대기하고 있다가, 요청이 들어오면 이 풀의 한 스레드에게 요청을 할당
	- 작업 완료시 다시 풀로 돌아가 작업을 대기함.
* 장점
	- 기존 스레드를 재활용 하기 때문에 더 빠르다.
* 단점
	- 요청이 매우 드물경우 쓸대없는 공간 낭비일수도 있다.


### 4.4.5 Thread Specific Data
* 스레드 각각이 자신만 액세스할 수 있는 데이터
* 같은 전역변수가 서로 다른 메모리 영역을 가르키게 하는 방법을 사용하는데,
	다른 메모리 영역의 주소를 가르키는 각각의 다른 key 를 사용함으로서, 
	스레드간 개별적인 전역변수를 엑세스 할 수 있게 한다.
* 정적 TLS ( Thread Local Storage ) 와 동적 TLS 가 존재하는데 정적 TLS 는 .tls 섹션을 사용하고
동적은 잘 모르겠다. 그닥 중요하진....

### Scheduler Activations
* 사용자 스레드 라이브러리와 커널 스레드 간의 통신 방법 중 하나.
	- 스레드 라이브러리와 커널의 통신 문제는 다대다 및 두수준 모델에서는 반드시 해결해야 할 문제이다.
* 커널은 어플리케이션에게 가상 처리기 집합 ( LWP ) 를 제공하고 어플리케이션은 사용자 스레드를 가용한
가상 처리기로 스케줄 한다.
	- 커널은 업콜( Upcall ) 을 통해 어클리케이션에게 특정 사건에 대해 알려준다.
	- 보통 업콜은 사용자 스레드가 봉쇄하려고 할 때 발생한다.
* 동작 순서
	1. 커널은 새로운 가상 처리기를 어플리케이션에 할당
	2. 봉쇄 등의 업콜이 발생하면 어플리케이션은 새로운 가상처리기 상에서 업콜 처리기를 실행
	3. 새로운 가상 처리기 상에서 업콜 처리기는 봉쇄 스레드의 상태를 저장하고, 
	이 스레드가 실행중이던 가상 처리기를 반환
	4. 봉쇄된 스레드가 기다리던 사건이 발생하면 커널은 이전에 봉쇄된 스레드가 이제 실행 가능하다는 사실을 알려주는
	또 다른 업콜을 스레드 라이브러리에 전달.
	5. 이 사건을 처리하는 업콜 처리기도 가상 처리기가 필요하므로, 커널은 새로운 가상 처리기를 할당하거나
	사용자 스레드 하나를 선점하여 그 처리기에서 이 업콜 처리기를 실행
	6. 봉쇄가 풀린 스레드를 실행 가능한 상태로 표시한 후에 어플리케이션은 가용한 가상 처리기 상에서 
	다른 실행 가능한 스레드를 실행

#### 용어
* LWP ( Light Weight Process )
	- 사용자 스레드와 커널 스레드 사이의 중간 자료 구조.
	- 각 LWP 는 하나의 커널 스레드에 부속되어 있으며, 물리 처리기에서 스케줄 하는 대상은 바로 이 커널 스레드.
	- 입출력이 완료되기를 기다리는 동안 같이 커널 스레드가 봉쇄되면 LWP 도 봉쇄된다.
	- 사용자 스레드 라이브러리에게 LWP 방식은 어플리케이션이 사용자 스레드를 실행하기 위하여
	스케줄할 가상처리기로 보인다.
	- 통상적으로 동시에 발생하는 봉쇄형 시스템 호출마다 하나의 LWP 가 필요하다.
		- 만약 LWP 가 4개이고, 서로 다른 5 개의 읽기 요청이 있을 때, 
		5 번째 요청은 하나의 LWP 라도 커널에 복귀할 때까지 기다려야 한다.
* Upcall & Callback
	- Upcall
		- 커널에서 프로세스에게 그 프로세스가 요구한 일이 끝났음을 알리는 신호
	- Callback
		- 어떤 이벤트와 그 이벤트가 발생했을 때 실행 시킬 함수를 정해놓고, 
		그 이벤트가 발생 시 그 함수를 호출하는 방식

##### Light Weight Process
![4.12](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/chap4-lwp.png)

