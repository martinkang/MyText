# 원자적 트랜잭션 ( Atomic Transaction )

#### 용어
* 원자적 ( Atomic )
	- 어떤 것이 더 이상 쪼개질 수 없는 성질을 말한다. 어떤 것이 원자성을 가지고 있다면 원자적(atomic)이라고 한다
* 트랜잭션 ( Transaction )
	- 쪼갤 수 없는 업무 처리의 단위
	- 하나의 논리적인 기능을 실행하는 명령어 ( 또는 연산 ) 의 집합
	- 어떤 일이 있더라도 원자성을 보장해야 한다.
	- All or Nothing
* 롤백 ( Rollback )
	- 트랜잭션이 철회 ( Abort ) 될 때 트랜잭션 시작 이전으로 되돌린다.


## 시스템 모델
* 트랜잭션을 일련의 읽기 쓰기로 구성된 연산으로, 이런 연산은 완료 ( Commit ) 되거나 철회 ( Abort ) 되야 한다.
	- 철회된 트랜잭션이 이미 접근한 데이터를 변경했을 수도 있기 때문에 원자성을 보장하기 위해서는
	철회된 트랜잭션은 접근된 데이터의 상태에 어떠한 영향을 줘서는 안된다.
	- 따라서 철회된 트랜잭션에 의해 접근된 데이터의 상태는 트랜잭션 시작 이전의 값들로
	복원시켜줘야 한다. -> Rollback


## 로그 기반 복구 ( Log Based Recovery )
* 트랜잭션에 의해 접근된 데이터에 가해지는 모든 변경 내역을 안전 저장장치에 기록하고,
	필요에 따라 이를 복구하는 방식.
	- < Ti starts > 로그의 시작
	- < Ti commits > 로그가 완료되었음
* 각 로그 레코드는 트랜잭션 하나의 쓰기 연산을 설명하고 다음과 같은 필드를 가진다.
	- 트랜잭션 이름 : 이 쓰기 연산을 실행한 트랜잭션의 고유한 이름
	- 데이터 항목 이름 : 쓰인 데이터 항목의 고유한 이름
	- 이전 값 : 쓰기 연산 이전에 그 데이터 항목에 저장되어 있던 값
	- 새 값 : 이 쓰기 연산 이후에 그 데이터 항목에 저장될 값.
* 로그의 정보는 다양한 트랜잭션에 의해 접근된 데이터 항목의 값을 복원시키는 데 사용되므로
안전 저장장치에 해당 로그 레코드를 기록하기 전에는 데이터 항목에 대한 실제 갱신을 허용하지 않음.
	- 따라서 데이터 항목에 대한 Write(X) 연산을 실행하기 전에, X 에 해당하는 로그 레코드를
	먼저 안전 저장장치에 쓴다.
* 성능 손실을 감수해야 한다.
	- 각 논리적인 쓰기마다 두 번의 물리적인 쓰기가 발생.
	- 더 많은 저장 공간을 필요.
* 복구 알고리즘
	* 프로시저
		- undo( Ti )
			- Ti 가 갱신한 모든 데이터 항목의 값들을 Ti 가 시작되기 이전의 값으로 돌려놓는다.
		- redo( Ti )
			- Ti 가 갱신한 모든 데이터 항목에 새로운 값들을 넣는다.
	* 시스템 고장시 트랜잭션 분류 작업
		- 만약 < Ti start > 레코드는 있지만 < Ti commits > 레코드가 없다면,
		트랜잭션 Ti 는 undo 된다.
		- 로그에 < Ti start > 와 < Ti commits > 라는 두 개의 레코드가 다 있다면,
		트랜잭션 Ti 는 redo 된다.
	* undo 와 redo 연산은 반드시 idempotent 해야 한다.


#### 용어
* 로그 우선 쓰기 ( Write Ahead Logging )
	- 트랜잭션 발생 시 로그를 먼저 기록하고 연산을 수행
* idempotent
	- 연산을 여러번 실행해도 한번 실행한 것과 동일한 결과를 만들어 낸다.


## 체크포인트 ( Checkpoint )
* 전체 로그를 조사하면 redo/undo 할 트랜잭션을 검사 할 때 발생하는 오버헤드를 줄이기 위한 방법
	- 시스템 복구 작업을 보다 능률적으로 만들어 준다.
* 문제점
	- 시스템 고장이 일어나면 로그를 보면서 redo/undo 를 할 트랜잭션을 검사한다.
이 때 전체 로그를 조사하면 다음과 같은 문제가 발생한다.
		- 검색 작업에 시간 소요가 큼
		- 알고리즘에 의하면 로그가 redo 하라고 지목하는 대부분의 트랜잭션들은 이미 실제 데이터 항목도
		갱신한 상태로, 이런 데이터를 한번 더 redo 한다고 달라질 건 없지만
		시스템 복구 시간이 더 길어질 것이다.
* 체크포인트의 동작
	- 시스템은 주기적으로 다음과 같은 작업들로 구성된 체크포인트를 발생시키며,
	체크포인트는 다음고 가타은 작업을 수행한다.
		- 휘발성 저장장치에 있던 로그 레코드들을 모두 안전 저장장치로 출력한다.
		- 저장장치에서 변경된 모든 데이터 항목들을 안전 저장장치로 출력한다.
		- < checkpoint > 라는 로그 레코드를 안전 저장장치로 출력한다.
	- 트랜잭션 Ti 가 체크포인트 이전에 완료했다고 한다면
		- 로그에서 < Ti commit > 레코드가 < checkpoint > 레코드보다 앞서 나온다.
		- 그러면 Ti 가 실행한 모든 변경은 체크포인트 이전에 또는 체크포인트 작업의 일환으로
		안전 저장장치에 쓰여졌다.
		- 따라서 시스템 복구 시 이 Ti 에 대한 redo 는 할 필요가 없다.
* 복구 과정의 변화
	- 시스템 고장 시 복구 루틴은 가장 최근 체크포인트가 실행되기 전에 실행을 시작했던
	가장 최근의 트랜잭션 Ti 를 결정 하기 위하여 로그를 조사.
	- 로그를 거꾸로 조사하면서 먼저 첫 번째 < checkpoint > 레코드를 찾고,
	다시 < Ti start > 를 찾는다.
	- Ti 를 찾으면 그 Ti 와 Ti 이후에 시작된 모든 트랜잭션에 대해서만 redo/undo 를 적용한다.
		- T 에 속한 모든 Tk 에 대해 < Tk commit > 가 로그에 기록되어 있으면, 
		redo ( Tk ) 를 실행시킨다.
		- T 에 속한 모든 Tk 에 대해 < Tk commit > 가 로그에 기록되어 있지 않으면,
		undo( Tk ) 를 실행시킨다.


#### 체크포인트로 인한  복구 과정의 변화
![checkpoint](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/Chap6-checkpoint.png)
* 체크포인트 복구 과정
	- 시스템 다운시 로그를 거꾸로 읽어가며 첫번째 Checkpoint 를 찾는다.
	- 첫번째 Checkpoint 바로 이전 트랜잭션을 찾는다. => T2
	- T2 이전의 트랜잭션을 이미 Commit 됬음을 보장한다.
		- 만약 < T2 commit > 로그가 있다면 redo 를 실행하고 없다면 undo 를 한다.
	- 기존 방식은 T1 부터 전체 로그에 대해 rede/undo 를 했다면 체크 포인트로 인하여
	T2 부터 복구를 시작하여 복구작업의 효율을 높여준다.


## 동시 실행 원자적 트랜잭션 ( Concurrent Atomic Transactions )
* 다수의 트랜잭션들이 동시에 활성화 되는 경우를 고려한다.
	- 각 트랜잭션은 원자적이기 때문에 여러 트랜잭션을 병렬로 실행시키면 그 결과는, 
	이 모든 트랜잭션을 어떤 임의의 순서에 따라 하나씩 순차적으로 실행 시킨 것과 같아야 한다.


### 직렬가능성 ( Serializability )
* 어떤 트랜잭션을 병렬로 실행시키면 그 결과는, 이 모든 트랜잭션을 어떤 임의의 순서에 따라 하나씩 순차적으로 실행 시킨 것과 같아야 한다.

##### 스케줄 1 : T0 후에 T1 이 실행되는 직렬 스케줄
![serialize1](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/Chap6-serialize1.png)
* 직렬 스케줄은 여러 트랜잭션들의 명령어들이 순서로 구성되고 특정 트랜잭션에 속한
명령어들은 연속된 한 집합 형태로 나타낸다.
	- 따라서 n 개의 트랜잭션이 있다면 n! 개의 유효한 직렬 스케줄이 존재한다.
* 두 개의 트랜잭션을 중첩되게 실행시키면 그 결과는 더이상 직렬 스케줄이 아니다.
	- 그러나 이 비직렬 스케줄이 반드시 잘못된 스케줄은 아니다.


##### 스케줄 2 : 동시 실행 직렬 가능 스케줄
![serialize2](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/Chap6-serialize2.png)
* T0 의 Write(A) 연산은 T1 의 Read(A) 연산과 충돌한다. 
* Oi 와 Oj 가 스케줄 S 에서 인접해 나오는 연산이라고 하자. Oi 와 Oj 가 서로 다른 트랜잭션에 속했으면서
Oi 와 Oj 가 서로 충돌하지 않는다면 Oi 와 Oj 순서를 바꾸어 새로운 스케줄 S` 를 만들 수 있다.
	- 이 때 원래의 스케줄 S 와 S` 는 동등하다고 기대할 수 있다.
		- 직렬 가능성에 의해.
	- 이와 같은 요령으로 서로 충돌하지 않는 연산들의 순서를 계속해서 다음과 같이 바꿀 수 있다. => 스케줄 2
		- T0 의 Read(B) 연산과 T1 의 Read(A) 연산을 swap
		- T0 의 Write(B) 연산과 T1 의 Write(A) 연산을 swap
		- T0 의 Write(B) 연산과 T1 의 Read(A) 연산을 swap
	- 이처럼 일련의 swap 을 하면 그 결과는 스케줄 1과 같이 된다.


#### 용어
* 직렬 스케줄 ( Serial Schedule )
	- 각 트랜잭션들이 원자적으로 실행되는 스케줄
* 충돌 ( Conflict )
	- Oi 와 Oj 가 동일한 데이터 항목을 액세스하며, 그 중 적어도 하나가 쓰기 연산일 대 Oi 와 Oj 가 충돌 ( conflict ) 한다고 한다.
* swap
	- 어떤 연산 Oi 와 Oj 가 다른 트랜잭션에 있으면서 충돌하지 않는다면, Oi 와 Oj 의 순서를 바꾸어 새로운 스케줄을 만들 수 있다.
* 충돌 직렬가능 ( conflict serializable )
	- 스케줄 S 에 있는 일련의 비충돌 연산들을 서로 swap 시켜줌으로써 직렬 스케줄 S` 로 변환시켜 줄 수 있다면
	S 가 충돌 직렬가능 하다고 한다.


### 락킹 프로토콜 ( Locking Protocol )
* 각 데이터 항목마다 락을 두고, 각 트랜잭션이 일정한 락킹 프로토콜에 맞추어 락을 획득하고 반납하도록 하여 직렬 가능성을 보장시키는 방법.
	* 종류
		- 공유
			- 트랜잭션 Ti 가 데이터 항목 Q 에 대한 공유 모드락 ( S ) 를 가지고 있으면 Ti 는 Q 를 read 할 수 있지만 Q 에 쓸 수는 없다.
		- 독점
			- 트랜잭션 Ti 가 데이터 항목 Q 에 대한 독점 모드락 ( X ) 를 가지고 있으면 Ti 는 Q 에 읽기아 쓰기를 모두 할 수 있다.
	* 트랜잭션들은 그들의 데이터 항목 Q 에 처리해야 할 작업의 유형에 맞추어 적절한 모드의 락을 요청해야 한다.
	* 두 개의 충돌하는 트랜잭션 사이의 실행순서는 실행 중에 결정된다.
	- 데이터 항목에 대한 마지막 액세스가 끝나자마자 바로 락을 해제하는 것은 직렬가능서잉 보장되지 않을 수 있기 때문에
	바람직하지 않을 수 있다. => 왜지??
* 두 단계 락킹 프로토콜 ( Two phase Locking Protocol )
	- 직렬가능성을 보장해 주는 프로토콜의 하나.
		- 확장 단계 ( growing phase )
			- 트랜잭션은 락을 새로 얻을 수는 있지만 얻었던 락을 반납해서는 안된다.
		- 수축 단계 ( shrinking phase )
			- 트랜잭션은 얻었던 락을 반납할 수는 있지만 새로운 락을 얻어서는 안된다.
	- 트랜잭션은 최초에는 확장 단계에서 시작하고, 필요한 만큼의 락을 확보한다.
		- 트랜잭션이 일단 한 개의 락을 해제하기 시작하면 수축 단계로 들어가며 그 이후부터는 새로운 락을 획득해서는 안된다.
	- 교착상태 문제로부터 자유롭지 못한다.


##### 락킹 프로토콜의 교착상태
![locking-deadlock](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/Chap6-locking-deadlock.png)
* T0 가 Write_Lock(B) 를 잡으려 하지만 T1 가 Read_Lock(B) 를 잡고 있기 때문에 Lock 획득을 하지 못하고
 마찬가지로 T1 도 Write_Lock(A) 를 획득하지 못하는 교착상태가 발생한다.


### 타임스탬프 기반 프로토콜 ( Timestamp Based Protocols )
* 두 개의 충돌하는 트랜잭션 사이의 실행순서를 미리 선택하는 방법.
* 시스템은 각 트랜잭션 Ti 마다 고유한 고정 타임스탬프 TS(Ti) 를 부여한다.
	- 이 타임 스탬프는 트랜잭션 Ti 가 실행을 시작하기 이전에 시스템에 의해 부여된다.
		- TS(Ti) < TS(Tj) => 시스템은 생성된 스케줄이 Ti 를 처리한 후 Tj 를 처리하는 직렬 스케줄과 동등하도록 보장해야 한다.
	* 타임스탬프 구현 방법
		- 시스템 클록
			- 트랜잭션이 시스템에 도착할 당시 클록의 값.
			- 이 방법은 별도의시스템에서 실행되거나 두 처리기가 클록을 공유하지 않는 환경에서 실행되는
			트랜잭션에는 사용될 수 업삳.
		- 논리적인 카운터
			- 트랜잭션이 시스템에 도착할 당시 논리적인 카운터 값.
			- 카운터는 새 타임스탬프가 부여된 후에 증가.
	* 타임 스탬프의 종류
		- W-timestamp(Q)
			- write(Q) 를 성공적으로 실행한 트랜잭션의 타임스탬프 중 가장 큰 값.
		- R-timestamp(Q)
			- read(Q) 를 성공적으로 실행한 트랜잭션의 타임스탬프 중 가장 큰 값.
	* 타임 스탬프의 동작
		- 트랜잭션 Ti 가 read(Q) 를 요청했다.
			- TS(i) < W-timestamp(Q) 이면, 그것은 Ti 가 이미 겹처쓰기된 Q 값을 읽고자 한다는 뜻이다. 따라서 read 연산이 거부되고 Ti 는 롤백된다.
			- TS(i) >= W-timestamp(Q) 이면, read 연산이 실행되고 R-timestamp(Q) 는 R-timestamp(Q) 와 TS(Ti) 중 큰 값으로 지정된다.
		- 트랜잭션 Ti 가 write(Q) 를 요청했다.
			- TS(Ti) < R-timestamp(Q) 이면, 그것은 Ti 가 생성하는 Q 의 값이 이미 과거에 필요했고 T
			i 는 이 값이 생성되지 않았을 것이라고 가정했음을 뜻한다.
			따라서 write 요청은 거부되고 Ti 는 롤백된다.
			- TS(Ti) < W-timestamp(Q) 이면, Ti 는 이미 소용없게 된 값을 Q 에 쓰려고 하는 것임을 뜻한다.
			따라서 write 연산은 거부되고 Ti 는 롤백된다.
		- 기타
			- write 연산이 실행된다.
* 타임스탬프 프로토콜은 충돌 직렬가능성을 보장
	- 서로 충돌 관계에 있는 연산들이 타임스탬프 순서에 따라 실행되기 때문
* 타임스탬프 프로토콜은 교착상태를 유발하지 않는다.
	- 이 프로토콜에서는 트랜잭션들이 서로를 기다리는 일이 없기 때문이다.
		- 왜?


##### 스케줄 3 : 타임스탬프 프로토콜에 의해 가능한 스케줄
![serialize3](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/Chap6-serialize3.png)
* 두 개의 트랜잭션 T0 과 T1 을 실행시키고 있다.
	- 스케줄 3 에 의하면 TS(T0) < TS(T1) 이다.

