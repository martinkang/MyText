# 원자적 트랜잭션 ( Atomic Transaction )

#### 용어
* 원자적 ( Atomic )
	- 어떤 것이 더 이상 쪼개질 수 없는 성질을 말한다. 어떤 것이 원자성을 가지고 있다면 원자적(atomic)이라고 한다
* 트랜잭션 ( Transaction )
	- 쪼갤 수 없는 업무 처리의 단위
	- 하나의 논리적인 기능을 실행하는 명령어 ( 또는 연산 ) 의 집합
	- 어떤 일이 있더라도 원자성을 보장해야 한다.
	- All or Nothing
* 롤백 ( Rollback )
	- 트랜잭션이 철회 ( Abort ) 될 때 트랜잭션 시작 이전으로 되돌린다.


## 시스템 모델
* 트랜잭션을 일련의 읽기 쓰기로 구성된 연산으로, 이런 연산은 완료 ( Commit ) 되거나 철회 ( Abort ) 되야 한다.
	- 철회된 트랜잭션이 이미 접근한 데이터를 변경했을 수도 있기 때문에 원자성을 보장하기 위해서는
	철회된 트랜잭션은 접근된 데이터의 상태에 어떠한 영향을 줘서는 안된다.
	- 따라서 철회된 트랜잭션에 의해 접근된 데이터의 상태는 트랜잭션 시작 이전의 값들로
	복원시켜줘야 한다. -> Rollback


## 로그 기반 복구 ( Log Based Recovery )
* 트랜잭션에 의해 접근된 데이터에 가해지는 모든 변경 내역을 안전 저장장치에 기록하고,
	필요에 따라 이를 복구하는 방식.
	- < Ti starts > 로그의 시작
	- < Ti commits > 로그가 완료되었음
* 각 로그 레코드는 트랜잭션 하나의 쓰기 연산을 설명하고 다음과 같은 필드를 가진다.
	- 트랜잭션 이름 : 이 쓰기 연산을 실행한 트랜잭션의 고유한 이름
	- 데이터 항목 이름 : 쓰인 데이터 항목의 고유한 이름
	- 이전 값 : 쓰기 연산 이전에 그 데이터 항목에 저장되어 있던 값
	- 새 값 : 이 쓰기 연산 이후에 그 데이터 항목에 저장될 값.
* 로그의 정보는 다양한 트랜잭션에 의해 접근된 데이터 항목의 값을 복원시키는 데 사용되므로
안전 저장장치에 해당 로그 레코드를 기록하기 전에는 데이터 항목에 대한 실제 갱신을 허용하지 않음.
	- 따라서 데이터 항목에 대한 Write(X) 연산을 실행하기 전에, X 에 해당하는 로그 레코드를
	먼저 안전 저장장치에 쓴다.
* 성능 손실을 감수해야 한다.
	- 각 논리적인 쓰기마다 두 번의 물리적인 쓰기가 발생.
	- 더 많은 저장 공간을 필요.
* 복구 알고리즘
	* 프로시저
		- undo( Ti )
			- Ti 가 갱신한 모든 데이터 항목의 값들을 Ti 가 시작되기 이전의 값으로 돌려놓는다.
		- redo( Ti )
			- Ti 가 갱신한 모든 데이터 항목에 새로운 값들을 넣는다.
	* 시스템 고장시 트랜잭션 분류 작업
		- 만약 < Ti start > 레코드는 있지만 < Ti commits > 레코드가 없다면,
		트랜잭션 Ti 는 undo 된다.
		- 로그에 < Ti start > 와 < Ti commits > 라는 두 개의 레코드가 다 있다면,
		트랜잭션 Ti 는 redo 된다.
	* undo 와 redo 연산은 반드시 idempotent 해야 한다.


#### 용어
* 로그 우선 쓰기 ( Write Ahead Logging )
	- 트랜잭션 발생 시 로그를 먼저 기록하고 연산을 수행
* idempotent
	- 연산을 여러번 실행해도 한번 실행한 것과 동일한 결과를 만들어 낸다.


## 체크포인트 ( Checkpoint )
* 전체 로그를 조사하면 redo/undo 할 트랜잭션을 검사 할 때 발생하는 오버헤드를 줄이기 위한 방법
	- 시스템 복구 작업을 보다 능률적으로 만들어 준다.
* 문제점
	- 시스템 고장이 일어나면 로그를 보면서 redo/undo 를 할 트랜잭션을 검사한다.
이 때 전체 로그를 조사하면 다음과 같은 문제가 발생한다.
		- 검색 작업에 시간 소요가 큼
		- 알고리즘에 의하면 로그가 redo 하라고 지목하는 대부분의 트랜잭션들은 이미 실제 데이터 항목도
		갱신한 상태로, 이런 데이터를 한번 더 redo 한다고 달라질 건 없지만
		시스템 복구 시간이 더 길어질 것이다.
* 체크포인트의 동작
	- 시스템은 주기적으로 다음과 같은 작업들로 구성된 체크포인트를 발생시키며,
	체크포인트는 다음고 가타은 작업을 수행한다.
		- 휘발성 저장장치에 있던 로그 레코드들을 모두 안전 저장장치로 출력한다.
		- 저장장치에서 변경된 모든 데이터 항목들을 안전 저장장치로 출력한다.
		- < checkpoint > 라는 로그 레코드를 안전 저장장치로 출력한다.
	- 트랜잭션 Ti 가 체크포인트 이전에 완료했다고 한다면
		- 로그에서 < Ti commit > 레코드가 < checkpoint > 레코드보다 앞서 나온다.
		- 그러면 Ti 가 실행한 모든 변경은 체크포인트 이전에 또는 체크포인트 작업의 일환으로
		안전 저장장치에 쓰여졌다.
		- 따라서 시스템 복구 시 이 Ti 에 대한 redo 는 할 필요가 없다.
* 복구 과정의 변화
	- 시스템 고장 시 복구 루틴은 가장 최근 체크포인트가 실행되기 전에 실행을 시작했던
	가장 최근의 트랜잭션 Ti 를 결정 하기 위하여 로그를 조사.
	- 로그를 거꾸로 조사하면서 먼저 첫 번째 < checkpoint > 레코드를 찾고,
	다시 < Ti start > 를 찾는다.
	- Ti 를 찾으면 그 Ti 와 Ti 이후에 시작된 모든 트랜잭션에 대해서만 redo/undo 를 적용한다.
		- T 에 속한 모든 Tk 에 대해 < Tk commit > 가 로그에 기록되어 있으면, 
		redo ( Tk ) 를 실행시킨다.
		- T 에 속한 모든 Tk 에 대해 < Tk commit > 가 로그에 기록되어 있지 않으면,
		undo( Tk ) 를 실행시킨다.


#### 체크포인트로 인한  복구 과정의 변화
![checkpoint](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/Chap6-checkpoint.png)
* 체크포인트 복구 과정
	- 시스템 다운시 로그를 거꾸로 읽어가며 첫번째 Checkpoint 를 찾는다.
	- 첫번째 Checkpoint 바로 이전 트랜잭션을 찾는다. => T2
	- T2 이전의 트랜잭션을 이미 Commit 됬음을 보장한다.
		- 만약 < T2 commit > 로그가 있다면 redo 를 실행하고 없다면 undo 를 한다.
	- 기존 방식은 T1 부터 전체 로그에 대해 rede/undo 를 했다면 체크 포인트로 인하여
	T2 부터 복구를 시작하여 복구작업의 효율을 높여준다.


## 동시 실행 원자적 트랜잭션 ( Concurrent Atomic Transactions )
### 직렬가능성 ( Serializability )
### 락킹 프로토콜 ( Locking Protocol )
### 타임스탬프 기반 프로토콜 ( Timestamp Based Protocols )

