# 프로세스 동기화
* 논리적 주소 공간을 공유하는 협력적 프로세스의 질서있는 실행을 보장하고, 
	데이터의 일관성을 유지하기 위해서는 동기화를 필요로 한다.
* 협력적 프로세스
	- 시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나 받는 프로세스

## 6.2 임계영역 문제 ( The Critical Section Problem )
* 임계영역문제의 해결안은 다음의 세 가지 조건을 만족해야 한다.
	* 상호배제
		- 오로지 하나의 프로세스만이 임계영역에서 실행될 수 있다.
	* 진행
		- 임계영역에서는 진입 영역에 있는 프로세스만 참여할 수 있다.
			- 진입허가를 요청하지 않고 임계영역에 들어오면 안된다.
	* 한정된 대기
		- 대기가 무제한 되지 않고 제한이 있어야 한다.
```c++
void sync()
{
	pthread_mutex sMtx;
	do
	{
		/* 진입영역 */
		lock( &sMtx );
		
		/* 임계영역 */
		a = getA();
		b = getB();

		/* 퇴출 영역 */
		unlock( &sMtx );

		/* 나머지 영역 */
		sum( a, b );
	}
}
```

#### 용어
* 임계 영역 ( The Critical Section )
	- 병렬 컴퓨팅에서 둘 이상의 스레드가 접근하면 안되는 공유자원 ( 자료 또는 장치 ) 를
	접근하는 코드의 일부
* 진입 영역 ( Entry Section )
	- 각 프로세스가 임계영역으로 진입하기 위해 진입허가를 요청하는 코드 부분
* 퇴출 영역 ( Exit Section )
	- 임계영역의 끝
* 나머지 영역 ( Remainder Section )
	- 그 외 영역

* 바쁜 대기 ( Busy Waiting )
	- 임계영역에 진입 하려고 진입 코드를 계속 반복 실행
	- 프로세스가 락을 기다리는 동안 반복문을 반복하며 CPU 시간을 낭비한다.
	- Context Switching 이 일어나지 않아 짧은 대기만 할 경우에는 오버헤드가 적다.


## 6.3 피터슨의 해결안
* 임계 영역에 대한 고전적인 소프트웨어 기반 해결책.
	- 현대 컴퓨터 구조가 load 와 store 같은 기본적인 기계어를 실행하는 방식 대문에
	피터슨의 해결안이 이러한 구조에서 올바르게 실행된다고 보장할 수 없다.
	- 그러나 임계 영역 문제를 해결하기 위한 좋은 알고리즘적인 설명을 제공하고,
	상호 배제, 진행, 한정된 대기의 요구조건을 중점으로 다루는 소프트웨어를 설계하는데
	수반되는 복잡함을 잘 설명할 수 있다.
* 피터슨의 해결안은 임계 영역과 나머지 영역을 번갈아 가며 실행하는 두 개의 프로세스로 한정된다.
	- 프로세스 p0, p1 ( 하나의 프로세스가 i 이면 나머지 하나는 j 가 된다. )
	- 프로세스가 다음 두 개의 데이터 항목을 공유한다.
		- int turn;
		- boolean flag[2];
	* turn 은 임계 영역으로 진입할 순번을 나타낸다.
		- turn == i 이면 프로세스 Pi 가 임계 영역에서 실행될 수 있다.
	* flag 배열은 프로세스가 임계 영역으로 진입할 준비가 되었다는 것을 나타낸다.
		- flag[i] == TRUE 이면 이 값은 Pi 가 임계 영역으로 진입할 준비가 되었다는 것을 나타낸다.

```c++
/* Pi 의 구조. Pj 는 여기에서 i 와 j 를 뒤바꾸면 된다. */
do
{
	flag[i] = TRUE;
	turn = j;
	while ( flag[j] == TRUE && turn == j );

	/* critical section */

	flag[i] = FALSE;

	/* remainder section */

} while( TRUE );
```
* 이 해결책이 올바르게 동작하는 것을 증명하기 위해선 다음과 같은 사실을 보여야 한다.
	- 상호 배제가 제대로 지켜진다는 사실
	- 진행에 대한 요구 조건을 만족한다는 사실.
	- 대기 시간이 한없이 길어지지 않는다는 사실.


#### 상호 배제가 제대로 지켜지는가?
* 프로세스 Pi 가 임예 영역에 들어가기 위해서는 반드시 flag[j] == FALSE 이거나 turn == i 여야 한다.
	- turn 값이 만약 0 이라면 ( 위 코드에서 j = 0 이고 i = 1 이라면 )
	P0 이 임계영역에서 실행될 것이고, 임계영역 실행이 끝나고 flag[1] = FALSE 로 세팅된다.
		- P1 은 flag[1] 이 FALSE 가 되었으므로 임계영역에 진입한다.
	- turn 값은 0 또는 1 둘 중 하나의 값만 가지기 때문에 두개의 프로세스가 동시에 들어갈 수 없다.
	또한 이 상태는 ( turn 과 flag 값 ) 임계영역을 빠져나올때까지 변하지 않는다.
		- 따라서 상호 배제가 지켜진다.


#### 진행에 대한 요구 조건이 만족하는가? ( Progress )

#### 대기 시간이 한없이 길어지지 않는가? ( Bounded Waiting )

## 6.4 동기화 하드웨어
* 임계 영역 문제에 대한 소프트웨어 기반 해결책은 현대의 컴퓨터 구조에서 올바르게 동작한다는 것을
보장하지 않는다. 대신에 일반적으로 임계영역에 대한 임의의 해결책은 락 ( lock ) 이란 간단한 도구가
필요하다.
	- 프로세스는 임계영역에 진입하기 전에 락을 획득하고, 임계영역을 나올때 락을 방출한다.

```c++
/* Lock 을 사용한 임계 영역의 해결책 */

do
{
		lock();

		/* 임계영역 */

		unlock();

		/* 나머지 영역 */
} whild( TRUE );
```


### 싱글 프로세서 환경에서 임계 영역과 인터럽트
* 발생 가능한 문제
	* 싱글 프로세서 환경에서 임계 영역 작업시 인터럽트가 발생하면 어떻게 될까?
		- 프로세스 P1 이 공유 변수 A 값은 2 에서 3 으로 변경중이다.
		- 인터럽트가 발생하여 인터럽트 핸들러가 수행되었다.
		- 인터럽트 핸들러에서 공유 변수 A 의 값에 5 를 더해준다.
		- 인터럽트 핸들러가 끝나고 프로세스 P1 의 실행 재개
		- A 의 값은 ??
	* 위와 같이 임계 영역 작업시 인터럽트가 발생하면 공유 변수에 예측못한 변경이 발생할 수 있다.
* 해결방법
	* 공유 변수가 변경하는 동안에 인터럽트 발생을 허용하지 않는다.
		- 이로 인해 명령어의 현재 순서가 선점되지 않고 순차적으로 실행됨을 확신할 수 있다.
		- 비선점형 커널이 이 방법을 사용


### 멀티 프로세서 환경에서 임계 영역과 인터럽트

