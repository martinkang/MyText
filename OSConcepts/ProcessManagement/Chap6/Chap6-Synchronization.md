# 프로세스 동기화
* 논리적 주소 공간을 공유하는 협력적 프로세스의 질서있는 실행을 보장하고, 
	데이터의 일관성을 유지하기 위해서는 동기화를 필요로 한다.
* 협력적 프로세스
	- 시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나 받는 프로세스

## 6.2 임계영역 문제 ( The Critical Section Problem )
* 임계영역문제의 해결안은 다음의 세 가지 조건을 만족해야 한다.
	* 상호배제
		- 오로지 하나의 프로세스만이 임계영역에서 실행될 수 있다.
	* 진행
		- 임계영역에서는 진입 영역에 있는 프로세스만 참여할 수 있다.
			- 진입허가를 요청하지 않고 임계영역에 들어오면 안된다.
	* 한정된 대기
		- 대기가 무제한 되지 않고 제한이 있어야 한다.
```c++
void sync()
{
	pthread_mutex sMtx;
	do
	{
		/* 진입영역 */
		lock( &sMtx );
		
		/* 임계영역 */
		a = getA();
		b = getB();

		/* 퇴출 영역 */
		unlock( &sMtx );

		/* 나머지 영역 */
		sum( a, b );
	}
}
```

#### 용어
* 임계 영역 ( The Critical Section )
	- 병렬 컴퓨팅에서 둘 이상의 스레드가 접근하면 안되는 공유자원 ( 자료 또는 장치 ) 를
	접근하는 코드의 일부
* 진입 영역 ( Entry Section )
	- 각 프로세스가 임계영역으로 진입하기 위해 진입허가를 요청하는 코드 부분
* 퇴출 영역 ( Exit Section )
	- 임계영역의 끝
* 나머지 영역 ( Remainder Section )
	- 그 외 영역

* 바쁜 대기 ( Busy Waiting )
	- 임계영역에 진입 하려고 진입 코드를 계속 반복 실행
	- 프로세스가 락을 기다리는 동안 반복문을 반복하며 CPU 시간을 낭비한다.
	- Context Switching 이 일어나지 않아 짧은 대기만 할 경우에는 오버헤드가 적다.


## 6.3 피터슨의 해결안

## 6.4 동기화 하드웨어
* 임계 영역 문제에 대한 소프트웨어 기반 해결책은 현대의 컴퓨터 구조에서 올바르게 동작한다는 것을
보장하지 않는다. 대신에 일반적으로 임계영역에 대한 임의의 해결책은 락 ( lock ) 이란 간단한 도구가
필요하다.
	- 프로세스는 임계영역에 진입하기 전에 락을 획득하고, 임계영역을 나올때 락을 방출한다.

```c++
/* Lock 을 사용한 임계 영역의 해결책 */

do
{
		lock();

		/* 임계영역 */

		unlock();

		/* 나머지 영역
} whild( TRUE );
```


### 멀티 프로세서 환경에서의 인터럽트

