# 프로세스 동기화
* 논리적 주소 공간을 공유하는 협력적 프로세스의 질서있는 실행을 보장하고, 
	데이터의 일관성을 유지하기 위해서는 동기화를 필요로 한다.
* 협력적 프로세스
	- 시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나 받는 프로세스

## 6.2 임계영역 문제 ( The Critical Section Problem )
* 임계영역문제의 해결안은 다음의 세 가지 조건을 만족해야 한다.
	* 상호배제
		- 오로지 하나의 프로세스만이 임계영역에서 실행될 수 있다.
	* 진행
		- 임계영역에서는 진입 영역에 있는 프로세스만 참여할 수 있다.
			- 진입허가를 요청하지 않고 임계영역에 들어오면 안된다.
	* 한정된 대기
		- 대기가 무제한 되지 않고 제한이 있어야 한다.
```c++
void sync()
{
	pthread_mutex sMtx;
	do
	{
		/* 진입영역 */
		lock( &sMtx );
		
		/* 임계영역 */
		a = getA();
		b = getB();

		/* 퇴출 영역 */
		unlock( &sMtx );

		/* 나머지 영역 */
		sum( a, b );
	}
}
```

#### 용어
* 임계 영역 ( The Critical Section )
	- 병렬 컴퓨팅에서 둘 이상의 스레드가 접근하면 안되는 공유자원 ( 자료 또는 장치 ) 를
	접근하는 코드의 일부
* 진입 영역 ( Entry Section )
	- 각 프로세스가 임계영역으로 진입하기 위해 진입허가를 요청하는 코드 부분
* 퇴출 영역 ( Exit Section )
	- 임계영역의 끝
* 나머지 영역 ( Remainder Section )
	- 그 외 영역
* 바쁜 대기 ( Busy Waiting )
	- 임계영역에 진입 하려고 진입 코드를 계속 반복 실행
	- 프로세스가 락을 기다리는 동안 반복문을 반복하며 CPU 시간을 낭비한다.
	- Context Switching 이 일어나지 않아 짧은 대기만 할 경우에는 오버헤드가 적다.


## 6.3 피터슨의 해결안
* 임계 영역에 대한 고전적인 소프트웨어 기반 해결책.
	- 현대 컴퓨터 구조가 load 와 store 같은 기본적인 기계어를 실행하는 방식 대문에
	피터슨의 해결안이 이러한 구조에서 올바르게 실행된다고 보장할 수 없다.
	- 그러나 임계 영역 문제를 해결하기 위한 좋은 알고리즘적인 설명을 제공하고,
	상호 배제, 진행, 한정된 대기의 요구조건을 중점으로 다루는 소프트웨어를 설계하는데
	수반되는 복잡함을 잘 설명할 수 있다.
* 피터슨의 해결안은 임계 영역과 나머지 영역을 번갈아 가며 실행하는 두 개의 프로세스로 한정된다.
	- 프로세스 p0, p1 ( 하나의 프로세스가 i 이면 나머지 하나는 j 가 된다. )
	- 프로세스가 다음 두 개의 데이터 항목을 공유한다.
		- int turn;
		- boolean flag[2];
	* turn 은 임계 영역으로 진입할 순번을 나타낸다.
		- turn == i 이면 프로세스 Pi 가 임계 영역에서 실행될 수 있다.
	* flag 배열은 프로세스가 임계 영역으로 진입할 준비가 되었다는 것을 나타낸다.
		- flag[i] == TRUE 이면 이 값은 Pi 가 임계 영역으로 진입할 준비가 되었다는 것을 나타낸다.

```c++
/* Pi 의 구조. Pj 는 여기에서 i 와 j 를 뒤바꾸면 된다. */
do
{
	flag[i] = TRUE;
	turn = j;
	while ( flag[j] == TRUE && turn == j );

	/* critical section */

	flag[i] = FALSE;

	/* remainder section */

} while( TRUE );
```
* 이 해결책이 올바르게 동작하는 것을 증명하기 위해선 다음과 같은 사실을 보여야 한다.
	- 상호 배제가 제대로 지켜진다는 사실
	- 진행에 대한 요구 조건을 만족한다는 사실.
	- 대기 시간이 한없이 길어지지 않는다는 사실.


#### 상호 배제가 제대로 지켜지는가?
* 프로세스 Pi 가 임예 영역에 들어가기 위해서는 반드시 flag[j] == FALSE 이거나 turn == i 여야 한다.
	- turn 값이 만약 0 이라면 ( 위 코드에서 j = 0 이고 i = 1 이라면 )
	P0 이 임계영역에서 실행될 것이고, 임계영역 실행이 끝나고 flag[1] = FALSE 로 세팅된다.
		- P1 은 flag[1] 이 FALSE 가 되었으므로 임계영역에 진입한다.
	- turn 값은 0 또는 1 둘 중 하나의 값만 가지기 때문에 두개의 프로세스가 동시에 들어갈 수 없다.
	또한 이 상태는 ( turn 과 flag 값 ) 임계영역을 빠져나올때까지 변하지 않는다.
		- 따라서 상호 배제가 지켜진다.


#### 대기 시간이 한없이 길어지지 않는가? ( Bounded Waiting ), 진행에 대한 요구 조건이 만족하는가? ( Progress )
* turn 값은 0 또는 1 둘 중 하나의 값을 가지기 때문에 Pi 또는 Pj 중 하나는 임계영역에 진입할 수 있다.
	- turn 이 i 라면 Pi 가 진입할 것이다.
	- Pi 가 임계 영역에 있고 Pj 가 while loop 에서 대기중에는 turn 과 flag 값이 변경되지 않는다.
	- Pi 가 임계 영역을 빠져 나올 때 flag[i] = FALSE 가 되어 Pj 로 하여금 임계영역에 진입하도록 만들어주고 
	Pj 역시 임계 영역에서 빠져 나올때 flag 값을 바꿔준다.
	- 따라서 둘 중 하나가 진입하였다면 그 다음번에는 반드시 다른 프로세스가 들어갈 수 있도록 보장된다.


## 6.4 동기화 하드웨어
* 임계 영역 문제에 대한 소프트웨어 기반 해결책은 현대의 컴퓨터 구조에서 올바르게 동작한다는 것을
보장하지 않는다. 대신에 일반적으로 임계영역에 대한 임의의 해결책은 락 ( lock ) 이란 간단한 도구가
필요하다.
	- 프로세스는 임계영역에 진입하기 전에 락을 획득하고, 임계영역을 나올때 락을 방출한다.

```c++
/* Lock 을 사용한 임계 영역의 해결책 */

do
{
		lock();

		/* 임계영역 */

		unlock();

		/* 나머지 영역 */
} whild( TRUE );
```


### 싱글 프로세서 환경에서 임계 영역과 인터럽트
* 발생 가능한 문제
	* 싱글 프로세서 환경에서 임계 영역 작업시 인터럽트가 발생하면 어떻게 될까?
		- 프로세스 P1 이 공유 변수 A 값은 2 에서 3 으로 변경중이다.
		- 인터럽트가 발생하여 인터럽트 핸들러가 수행되었다.
		- 인터럽트 핸들러에서 공유 변수 A 의 값에 5 를 더해준다.
		- 인터럽트 핸들러가 끝나고 프로세스 P1 의 실행 재개
		- A 의 값은 ??
	* 위와 같이 임계 영역 작업시 인터럽트가 발생하면 공유 변수에 예측못한 변경이 발생할 수 있다.
* 해결방법
	* 공유 변수가 변경하는 동안에 인터럽트 발생을 허용하지 않는다.
		- 이로 인해 명령어의 현재 순서가 선점되지 않고 순차적으로 실행됨을 확신할 수 있다.
		- 비선점형 커널이 이 방법을 사용


### 멀티 프로세서 환경에서 임계 영역과 인터럽트
* 발생 가능한 문제
	- 싱글 프로세서 환경과 동일
* 해결방법
	* 인터럽트 불능화는 사용할 수 없다.
		- 다중처리기 상에서 인터럽트의 불능화는 상당한 시간을 소비
			- 인터럽트가 불능화되었다는 메시지가 모든 프로세서에게 전달되어야 하기 때문에, 
			이런 메시지 전달은 매 임계 역역에 진입하는 것을 지연시켜 시스템 효율이 떨어짐.
		- 만약 인터럽트에 의해 클록이 갱신된다면, 시스템 클록에 대한 영향도 고려해야 한다.
	* 워드의 내용을 원자적으로 교환 할 수 있는, 인터럽트되지 않는 하나의 단위로서 특별한 하드웨어 명령어를 제공
		- TestAndSet() 과 Swap() 명령어 제공
		- 원자적 실행을 보장


#### TestAndSet() 과 Swap() 을 이용한 상호 배제
```c++
/* TestAndSet() 명령어 정의 */
Boolean TestAndSet( boolean *target )
{
	boolean rv = *target;
	*target = true;
	return rv;
}


/* TestAndSet() 명령어를 사용한 상호 배제를 구현 */
do
{
	while ( TestAndSet( &lock ) );

	// critical section

	lock = FALSE;

	// remainder section
} while ( TRUE );

/* Swap() 명령어 정의 */
void Swap( boolean *a, boolean *b )
{
	boolean temp = *a;
	*a = *b;
	*b = temp;
}

/* Swap() 명령어를 사용한 상호 배제 구현 */
do
{
	key = TRUE;
	while ( key == TRUE )
	{
		Swap( &lock, &key );
	}

	// critical section

	lock = FALSE;

	// remaider section
} while ( TRUE );
```
* 위의 TestAndSet() 은 상호 배제 조건은 만족시키지만 한정된 대기 조건을 만족시키지 못함.


#### TestAndSet() 명령어를 사용한 한정된 대기 조건을 만족시키는 상호 배제 
```c++
/* 모두 False 로 초기화 */
boolean wainting[n];
boolean lock;

/* TestAndSet() 명령어를 사용한 한정된 대기 조건을 만족시키는 상호 배제 */
{
	do
	{
		waiting[i] = TRUE;
		key = TURE;
		while ( waiting[i] && key )
		{
			key = TestAndSet( &lock );
		}
		waiting[i] = FALSE;

		// critical section

		j = ( i + 1 ) % n;
		while ( ( j != i ) && !waiting[j] )
		{
			j = ( j + 1 ) % n;
		}

		if ( j == i )
		{
			lock = FALSE;
		}
		else
		{
			waiting[j] = FALSE;
		}

		// remainder section
	} while ( TRUE );
}
```
* 맨 처음 key = TestAndSet( &lock ) 에 접근한 Process 는 lock 의 초기값 FALSE 를 리턴 받아 While 을 빠져나오고 임계 영역에 진입한다.
	- 나머지는 lock 값이 TRUE 이므로 while 에서 대기하게 된다.
* 만약 진입한 Pi 가 P1 이고 n 이 10 이라면
	- j = 2 가 된다. j = ( i + 1 ) % n  이므로 
	- 만약 P2 가 진입영역에 있다면 j != i 이고 waiting[2] == TRUE 이기 때문에 while ( ( j != i ) && !waiting[j] ) 에서 대기하지 않는다.
		- 만약 진입영역에 있지 않다면 waiting[2] 초기값은 FALSE 이기 때문에 while 문에서 진입영역에 진입한 j 를 찾게된다.
	- j!= i 이기 때문에 waiting[2] = FALSE 가 되고 P2 는  while ( waiting[i] && key ) 조건을 만족하지 않으므로 임계영역에 진입하게 된다.
		- 이로서 진입영역에 있는 모든 프로세스는 한정된 대기 조건을 만족시킨다.
