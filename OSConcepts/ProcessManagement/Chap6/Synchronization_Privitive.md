# 동기화 장치 ( Synchronization Privitive )
* 멀티 스레드 애플리케이션에서는 스레드 간의 정보 공유가 필수적이다. 
	- 스레드 간에 데이터를 공유하는 여러 방법과 각각의 오버헤드 비용을 알아본다.


#### 용어
* Data Race
	* 어떤 공유 데이터가 두 스레드 이상에게서 동시에 접근되는 상황
		- 모두 읽기 스레드라면 상관이 없고, 단 하나라도 쓰기 접근을 할 경우 Data Race 가 발생한다.
	* 방지법
		- 한 시점에 한 스레드만 변수를 업데이트 => 동기화 장치 사용
* Async-signal Safe
	- 시스템콜/표준 함수가 시그널로 인해 중단되었을 때, 시그널 처리기 내에서 다시 호출되어도 안전함
* Thread Safe
	- 여러 쓰레드에 의해 실행되어도 실행 결과의 정확성이 보장된다.
* Reentrant
	- 여러 쓰레드에 의해 코드가 동시에 수행될 수 있고, 그런 경우에도 실행 결과의 정확성이 보장된다.
	- reentrant 함수는 둘 이상의 쓰레드에 의해서 호출될 경우에 순서에 구애받지 않고, 
	서로 동일한 코드가 겹쳐서 실행되어도 작동이 보장되어야 함


## 동기화 장치 ( Synchronization Primitive )
* 스레드의 행동을 조율하기 위해 사용된다.
	- 특정 공유 리소스에 대한 접근을 한 번에 한 스레드만 해야 할 경우
	- 해당 리소스에 대한 작업이 완료되기 전에 다른 작업이 시작되지 않게 해야 하는 경우


### Mutex ( Mutually Execlusive Mutex )
* 상호 배타적인 잠금 메커니즘
	* 특정 시점에 오직 한 개의 스레드만이 뮤텍스 락을 얻을 수 있다.
	* 락을 기다리기 위해 bloking 상태가 되었을 때, 락이 해제 되더라도 운영체제에 의해 
	락을 기다리는 스레드가 다시 깨어나서 스케줄링된 이후에나 락을 얻을 수 있으므로
	대기 시간동안 CPU 자원을 다른 스레드에서 사용할 수 있게 양보.


### Spin Lock
* 락을 얻을 수 없을 때 슬립 모드로 빠지지 않고 지속적으로 락을 얻기 위한 시도를 한다.
	- Busy Wait
		- 슬립 모드에 빠지지 않고 지속적으로 CPU 를 점유하면서 기다린다.
	- 시스템 콜을 사용하지 않는다.
	- 락이 해제 되자마자 바로 락을 얻을 수 있어 지연이 적다.
	- 대기하는 동안 CPU 를 점유하므로 자원을 비효율 적으로 이용하게 만든다.
	- 락 경합이 많을때 비효율 적이다.


### Semaphore
* 세마포어는 카운터다.
* 세마포어 락을 획득하면 카운트가 감소하고 락을 해제하면 카운트가 증가한다.
* 세마포어는 특정 리소스의 개수가 한정되어 있고 여러 스레드에서 그 자원을 이용하려 할 때 
한정된 수만큼만 할당되게 만들 수 있다.


### Readers Writer Lock
* 여러 스레드에 공유 데이터에 대한 읽기를 허용하는 동시에 쓰기 작업을 하는 스레드에 대해서는
해당 공유 데이터에 대한 배타적인 접근을 제공
* Writer 는 Reader 가 락을 모두 해제하기 전에는 쓰기 락을 획들할 수 없다.
	- 대다수의 경우 writer lock 요청이 있을 경우 우선적으로 모든 Reader 를 블로킹 하여 
	Reader 스레드 개수를 점점 줄여 writer lock 배타적으로 획득
	- 큐를 이용하여 R/W lock 을 관리여러 스레드에 공유 데이터에 대한 읽기를 허용하는 동시에 
	Writer 스레드에 대해서는 해당 공유 데이터에 대한 배타적인 접근을 제공
* Writer 는 Reader 가 락을 모두 해제하기 전에는 쓰기 락을 획들할 수 없다.
	- 대다수의 경우 writer lock 요청이 있을 경우 우선적으로 모든 Reader 를 블로킹 하여 
	Reader 스레드 개수를 점점 줄여 writer lock 배타적으로 획득
* 큐를 이용하여 R/W lock 을 관리


### Atomic 연산
* 중간에 다른 스레드가 끼어들 여지가 없고 중간 결과를 시스템에서 엿보는 것조차 불가능한, 성공이든 실패든 무조건 완료된다.
* 동기화 장치를 사용하면 높은 오버헤드 비용이 따른다.
* 운영체제 또는 컴파일러에서 지원.
* Lock-free 코드를 만드는데 자주 이용.
* Lock-Free 코드
	- 뮤텍스 락에 의존하지 않으므로 락을 얻기 위한 절차를 타지 않아 성능이 훨씬 좋아진다.
	- 주로 Atomic 연산을 이용하여 만든다.
	- 뮤텍스 락은 한번에 한 스레드만 보호된 메모리에 접근 가능하므로 스레드가 자주 블로킹 되어
	효과 측면에서 바람직하지 않다.


#### Deadlock 과 Livelock
* Deadlock
	- 두 스레드가 서로 상대방이 가진 자원을 기다리느라 전혀 진도를 나가지 못하는 상황.
		- ex )
			- Thread 1 : lock A 획득 후 lock B 획득시도
			- Thread 2 : lock B 획득 후 lock A 획득 시도
	- 피하는 가장 좋은 방법은 스레드가 같은 순서로 락을 획득하게 하는 것.
	- timeout 을 이용할 경우 일시적 해결이 가능하지만 livelock 문제가 발생
* Livelock
	- 두 스레드가 락의 해제와 획득을 무한 반복하는 상태.
		-  ex)
			- Thread 1 : lock A 획득 후 B 를 획득할 수 있으면 B 획득 없으면 A 해제.
			- Thread 2 : lock B 획득 후 A 를 획득할 수 있으면 A 획득 없으면 B 해제.
  
