# 연습문제
* 5.1 스케줄러가 입출력 중심 프로그램과 CPU 중심 프로그램을 구분하는 것이 중요한가?
	- 중요하다
		- CPU / 입출력 중심 프로그램을 구분하면 스케줄링 최적화에 도움을 줄 수 있다.
* 5.3 10 개의 입출력 중심 태스크와 1 개의 CPU 중심 태스크를 실행하는 시스템을 고려 하자.
입출력 중심 태스크는 CPU 에서 1 밀리초 실행 후 한 번씩 입출력 요구를 하며,
	각 입출력 잡업은 완료될 때까지 10 밀리초가 걸린다고 가정하자. 
	또한 문맥 교환 오버헤드는 0.1 밀리초이고 모든 프로세스들은 장기간 실행되는 프로세스들이라고 가정하자.
	다음과 같은 시간 할당량을 가질 때 라운드 로빈 스케줄의 CPU 이용율은 얼마인가?
	- a. 시간 할당량 1 밀리초
		- CPU 중심 : 1 ms + 0.1 ms ( 오버헤드 비용 ) = 1.1 ms
		- 입출력 중심 : 1 ms + 0.1 ms ( 오버헤드 비용 ) = 1.1 ms * 10 ( 10 개 ) = 11 ms
		- 순 작업시간 : 1 ms ( CPU 중심 ) + 10 ms ( 입출력 ) = 11 ms
		- 실제 작업시간 : 1.1 ms + 11 ms = 12.1
		- CPU 이용률 = ( 순 작업시간 ) / ( 실제 작업시간 ) = 11 / 12.1 ms
	- b. 시간 할당량 10 밀리초
		- CPU 중심 : 10 ms + 0.1 ms ( 오버헤드 비용 ) = 10.1 ms
		- 입출력 중심 : 1 ms + 0.1 ms ( 오버헤드 비용 ) = 1.1 ms * 10 ( 10 개 ) = 11 ms
			- 입출력은 CPU burst 가 1 ms 이므로.
		- 순 작업시간 : 10 ms ( CPU 중심 ) + 10 ms ( 입출력 ) = 20 ms
		- 실제 작업시간 : 10.1 ms + 11 ms = 21.1
		- CPU 이용률 = ( 순 작업시간 ) / ( 실제 작업시간 ) = 20 / 21.1 ms
	* 여기서 입출력 요구는 모두 다른 장치로 요구 한다고 가정하고 풀었다. 한 장치를 모두 요구하면 계산이 짜증나진다....
* 5.4 다단계 큐 시스템에서 각 단계마다 다른 시간 할당량을 책정하는 것의 이점이 무엇인가?
	- 낮은 우선순위의 프로세스도 적지만 CPU 시간 할당을 받을 수 있으므로 기아 현상을 방지할 수 있지 않을까.
* 5.5 다단계 큐 스케줄링을 구현한 시스템을 고려하자. 
자신의 프로세스에게 할당된 CPU 시간을 최대로 하기 위해서 사용자는 어떤 전략을 세울 수 있는가?
	- 다단계 큐 스케줄링은 프로세스의 우선순위에 따라 영구적으로 하나의 큐에 할당된다.
	- 시스템 프로세스를 제외하고 대화형 프로세스가 가장 최우선 프로세스이므로 대화형으로 프로세스를 만들면 되려나?
	- 다단계 피드백 큐 문제를 잘못낸거 아닌가?
* 5.7 다음의 알고리즘들이 짧은 프로세스를 우대하는 정도의 차이에 대해 설명하시오
	- a. FCFS
		- 우대하지 않는다.
	- b. RR
		- 모두 평등하다.
	- c. 다단계 피드백 큐
		- 짧은 프로세스의 우선순위가 높아진다.
* 5.9 다음 알고리즘 중 기아 현상을 일으킬 수 있는 알고리즘은 무엇인가?
	- a. 선입 선처리
		- 들어온 순이기 때문에 기아현상 발생 안함
	- b. 최소 작업 우선
		- 기아 현상 발생 가능
		- 계속해서 작업시간이 짧은 프로세스가 들어오면 상대적으로 작업시간이 긴 프로세스는 할당 못받을 수 있다.
	- c. 라운드 로빈
		- 발생 안함
	- d. 우선순위
		- 최소 작업 우선과 마찬가지로 계속 우선순위 높은 프로세스가 들어오면 발생 가능
* 5.10 단기 CPU 스케줄링 단계에서 최근 과거 동안 처리기 시간을 가장 적게 사용한 프로세스를 우대하는 스케줄링 알고리즘을 가정하자.
이 알고리즘이 입출력-중심 프로그램을 선호하는 이유와
그러면서도 CPU 중심 프로그램을 기아 상태로 빠뜨리지 않는 이유를 설명하라.
	- 입출력-중심 을 선호하는 이유
		- 입출력-중심 프로그램은 CPU Burst 가 짧은 편이기 때문에 처리기 시간을 적게 사용하므로 우대된다.
	- 기아 상태에 빠지지 않는 이유
		- 결국 우선순위가 낮거나 처리기가 처리를 안한 프로세스는 처리기 시간을 가장 적게 사용하기 때문에
		결국 우대되어 처리가 될 것이다. 
			- 따라서 기아 현상이 발생하지 않을 것이다.
* 5.12 준비완료 큐의 항목이 프로세스 제어 블록에 대한 포인터인 라운드 로빈 스케줄링의 변형 알고리즘을 고려하자.
	- a. 준비완료 큐에 동일한 프로세스를 가르키는 두 개의 포인터를 넣는 결과는 무엇인가?
		- 연속해서 준비완료 큐에 넣지 않는다면 다른 프로세스에 비해 처리가 2배가 되므로 작업이 빨리 끝날거 같다.
	- b. 이 방식의 주요한 두 개의 장 단점은 무엇인가?
		- 장점
			- 빠른 작업 처리
		- 단점
			- 아래처럼 포인터를 복제해서 쓴다면 프로세스 작업이 끝나서 PCB 까지 다 정리한 상황에서
			스케줄러에 아직 남아있는 또 하나의 포인터가 댕글링 포인터가 되어 문제가 발생할듯.
	- c. 포인터를 복제하지 않고도 동일한 효과를 달성하려면 기본 라운드 로빈 알고리즘을 어떻게 변경해야 하는가?
		- 원래부터 스케줄러에 PCB 포인터를 달고있지 않나.... 이걸 복제하여 쓰던가?
		- 변경할 거 없이 처음부터 포인터만 달고 다녀도 될거 같은데....
	* 문제의 의도를 모르겠다... 나중에 찾아보고 채워야지...
* 5.13 다음 프로세스들의 집합을 생각해 보자. CPU 버스트 시간 단위는 밀리초이다.
프로세스들은 시간 0 에 P1, P2, P3, P4, P5 순서로 도착한다고 가정한다.
	* 프로세스 CPU 버스트 시간 및 우선순위
		- 프로세스 | 버스트시간 | 우선순위
		- --------------------------------
		-   P1         10    		 3
		-   P2          1            1
		-   P3          2            3
		-   P4          1            4
		-   P5          5            2
	- a. 선입 선처리, SJF, 비선점 우선순위 그리고 라운드 로빈 ( 할당량 1 ) 스케줄링을 이용해
	프로세스들의 실행을 보이는 Gantt 차트를 그리시오
	- b. a 에서 각 스케줄링 알고리즘의 각 프로세스에 대한 총처리 시간은 얼마인가?
	- c. a 에서 각 스케줄링 알고리즘의 각 프로세스에 대한 대기 시간을 얼마인가?
	- d. a 에서 어느 스케줄이 최소의 평균 대기 시간을 갖는가?
	* 힘들에 문제 써서 내버려 두기로... 굳이 이걸 그림 그려가면서 풀 필요는 없는거 같다.
* 5.15 다음과 같은 두 스케줄링 기준들은 어떤 상황에서 서로 충돌하는지 논의하시오
	- CPU 이용률과 응답시간
		- CPU 이용률이 높으려면 컨텍스트 스위칭이 적어야 한다. ( 순수 오버헤드이기 때문에 ) 
	하지만 응답시간은 여러 프로세스가 돌아가면서  CPU 를 점유해야 하므로 컨텍스트 스위칭이 자주 발생하게 되므로 상충된다.
	- 평균 총처리 시간과 최대 대기 시간
		- 최대 대기시간이 짧으려면 짧은 프로세스 우선 처리해야 하는데, 
		이를 위해 짧은 대기시간을 가진 프로세스가 긴 대기시간을 가진 프로세스를 선점시켜 버리면
		총 처리 시간이 늘어나게 된다.
	- 입출력장치 이용률과 CPU 이용률
		- 입출력 장치 이용시 CPU 는 놀게된다.
* 5.16 동적으로 변화하는 우선순위에 기반을 둔 다음의 선점형 우선순위 스케줄링 알고리즘에 대해 생각해보자.
우선순위 값이 클수록 높은 우선순위를 의미한다.
프로세스가 CPU 를 기다리는 중일 때 그 프로세스들의 우선순위는 a 의 비율로 변화한다.
프로세스가 실행되면 우선순위는 b 의 비율로 변한다.
준비완료 큐에 들어올 때 모든 프로세스들의 우선순위는 0으로 주어진다.
매개변수 a 와 b 의 값에 따라 여러 가지 다른 스케줄링 알고리즘이 만들어진다.
	- a. b > a > 0 이면, 무슨 알고리즘 인가?
		- 변화율이 양수이고 항상 대기중인 프로세스보다 실행중인 프로세스의 우선순위가 높다.	
			- 실행중일 때 우선순위가 높게 변하는거 보니 선점형 스케줄링일 거 같다.
			- FCFS 는 우선 아니다. ( 들어온 순서에 따라 불변이므로 )
			- SJF 가능성이 있다. 
				- 대기중에도 더 짧은 시간의 프로세스가 들어오면 우선순위가 바뀐다. 
				- 하지만 실행중에 더 잘 바뀌진 않으므로 아닌듯
			- RR 과 다단계 큐는 택도 없다.
				- RR 은 우선순위가 없고 다단계 큐는 우선순위 불변
			- 다단계 피드백 큐
				- 아마 이게 맞을듯?
	- b. a < b < 0 이면, 무슨 알고리즘 인가?
		- 변화율이 음수이고 항상 대기중인 프로세스가 실행중인 프로세스보다 우선순위가 높다.
			- 변화율이 음수가 될 수 있나??? 잘 모르것다.
			- 일단 대기중 프로세스가 실행중 프로세스보다 우선순위가 높은걸 보아 SJF 가 아닐까 싶다.
				- 실행중 보다 대기중에 더 짧은 시간의 프로세스가 들어오면 우선순위가 더 높게 바뀌므로
