# CPU 스케줄링
* 운영체제는 CPU 스케줄링을 통해 CPU 를 프로세스 간에 교환함으로써 컴퓨터를 보다 생산적으로 만든다.

## 5.1 기본개념
* 다중 프로그래밍의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 데 있다.
	- 어떤 프로세스가 대기하게 되면 ( I/O 요청등에 의해 ), 
	운영체제는 CPU 를 그 프로세스로부터 회수해 다른 프로세스에 할당한다.
	- 거의 모든 컴퓨터 자원은 사용되기 전에 스케줄 된다.

### 5.1.1 CPU-입출력 버스트 사이클 ( CPU-I/O Burst Cycle )
* 프로세스의 실행은 CPU 실행과 입출력 대기의 사이클로 구성된다. 프로세스들은 이들 두 상태 사이를 교대로 왔다 갔다 한다.
	- CPU Burst
		- CPU 가 실행되는 시간
	- I/O Burst
		- 입출력을 대기하는 시간

##### CPU 와 입출력 버스트의 교차
![5.1](http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling_files/image002.jpg)   
-출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling.htm


### 5.1.2 CPU 스케줄러
* CPU 가 유휴 상태가 될 때마다 운영체제는 준비완료 큐에 있는 프로세스들 중에서 실행될 프로세스를 선택해야 한다.
	- 선택 절차는 단기 스케줄러에 의해 실행된다.
	- 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스들 중에서 선택하여 이들 중 하나에게 CPU 를 할당.
	- 스케줄러에 있는 레코드들은 일반적으로 프레스스들의 PCB 이다.


### 5.1.3 선점 스케줄링 ( Preemptive Scheduling )
* CPU 스케줄링은 다음의 네 가지 상황 하에서 발생할 수 있다.
	1. 한 프로세스가 실행 상태에서 대기  상태로 전환될 때 ( 입출력 호출이나 자식 process 를 wait 할 때 )
	2. 프로세스가 실행 상태에서 준비 완료 상태로 전황될 때 ( 인터럽트가 발생 )
	3. 프로세스가 대기 상태에서 준비완료 상태로 전환될 때 ( 입출력 종료 시 )
	4. 프로세스가 종료할 때
* 1 과 4 는 선택의 여지가 없이 준비완료 큐에 있는 새로운 프로세스를 반드시 선택해야 한다.
	- 비선점 방식 / 협조적 이라고 한다.
#### 용어
* 선점 스케줄링 ( Preemptive )
	- 한 프로세스가 CPU 를 점유했을 때, 또 다른 프로세스가 이 CPU 를 강제로 가져와서 점유할 수 있도록 하는 방식
	- 공유 자료에 접근했을 때 문제를 야기시킬 수 있다.
		- 한 프로세스가 자료를 변경하는 동안 선점되어 두 번째 프로세스가 실행 가능하게 되었다. 
	이 때 이 프로세스가 첫 번째 프로세스가 수정하던 비일관적인 상태에 있는 자료를 읽으려 할 수 있다.
		- 따라서 이런 접근을 조정할 방법이 필요하며 비용이 발생한다.
* 비선점 스케줄링 ( Non-Preemptive )
	- CPU 가 한 프로세스에 할당되면, 프로세스가 종료하든지 대기 상태로 전환해 CPU 방출 할때까지 CPU 를 점유하는 방식.
	- 프로세스간 오버헤드가 적지만, 대화식 시분할 시스템에 적합하지 않다.
	- 하나의 긴 작업을 모든 프로세스가 계속 기다릴 수 있다.
	- Timer 와 같은 특수 하드웨어를 요구하지 않기 때문에 특정 기종에서 채택될 수 있다.


### 5.1.4 디스패처 ( Dispatcher )
* CPU 의 제어를 단기 스케줄러가 선택한 프로세스에게 주는 모듈
	* 하는 일
		- Context Switching
		- 사용자 모드로 전환하는 일
		- 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동 하는 일
* 디스패처는 모든 프로세스의 문맥 교환 ( Context Switching ) 시에 호출되므로, 가능한 한 빨라야 한다.

#### 용어
* 디스패치 지연 ( dispatch latency )
	- 디스패처가 하나의 프로세스를 중단시키고 다른 프로세스를 실행시키는 데까지 소요되는 시간


## 5.2 스케줄링 기준
* 서로 다른 CPU 스케줄링 알고리즘은 다른 특성을 가지고 있다.
	- 특정 상황에서 어떤 알고리즘을 선택하려면, 다양한 알고리즘들의 서로 다른 특성을 반드시 고려해야 한다.
* CPU 스케줄링 알고리즘을 비교하기 위해 사용되는 기준
	- CPU 이용률 ( utilization )
	- 처리량 ( throughput )
		- 단위 시간당 완료된 프로세스의 개수
	- 총처리 시간 ( turnaround time )
		- 프로세스의 제출 시간과 완료 시간의 간격
	- 대기 시간 ( waiting time )
	- 응답 시간 ( response time )
		- 하나의 요구를 제출한 후 첫 번째 응답이 나올 때 까지의 시간
		- Interactive System 에서 중요한 기준이 된다.


## 5.3 스케줄링 알고리즘

### 5.3.1 선입 선처리 스케줄링 ( First Come, First Served Scheduling : FCFS )
* CPU 를 먼저 요청하는 프로세스가 CPU 를 먼저 할당 받는다.
	- FIFO 큐로 관리
	- 비선점형 방식
* 절차
	- 프로세스가 준비 완료 큐에 진입하면, 이 프로세스의 PCB 를 큐의 끝에 연결한다.
	- CPU 가 자유상태가 되면, 준비완료 큐의 앞부분에 있는 프로세스에게 할당된다.
	- 이 실행중인 프로세스는 이어 준비완료 큐에서 제거된다.
* 단점
	- 평균 대기 시간은 종종 대단히 길 수 있다.
* ex )
	- P1 : 20 ms, P2 : 1 ms, P3 1 ms
	- P1, P2, P3 순으로 도착할 때 FCFS 평균 대기시간 = ( 0 + 20 + 21 ) / 3 = 41 / 3
	- P2, P3, P1 순으로 도착할 때 FCFS 평균 대기시간 = ( 0 + 1 + 1 ) / 3 = 2 / 3

##### Gantt 차트
![5.2](http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling_files/image004.gif)  
-출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling.htm

#### 용어
* 호위효과 ( Convoy Effect )
	- 모든 다른 프로세스들이 하나의 긴 프로세스가 CPU 를 양도하기 기다림


### 5.3.2 최단 작업 우선 스케줄링 ( Shortest Job First Scheduling : SJF )
* CPU 가 이용 가능해지면 CPU Burst 가 가장 작은 프로세스에게 할당.
	- 실제적으로 단기 CPU 스케줄링 상에선 구현이 어려운데, 이는 실제 CPU Burst 길이를 알 수 없기 때문
		- CPU Burst 를 이전 CPU Burst 들과 비슷하다고 가정하고 스케줄링
* 선점형/비선점형 모두 가능
	- 선점형일 경우 새로운 프로세스가 현재 실행하고 있는 프로세스의 남은 시간보다 더 짧은 CPU 버스트를 가질 경우,
	선점형 SJF 알고리즘은 현재 실행하는 프로세스를 선점할 것이다.


##### 선점형 SJF
![5.3](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/Chap5-sjf.png)
* ex )
	* 스케줄링 예제
		- P1 도착시간 0, 버스트 시간 8
		- P2 도착시간 1, 버스트 시간 4
		- P3 도착시간 2, 버스트 시간 9
		- P4 도착시간 3, 버스트 시간 5
	* 수행 순서
		- 0 시간에 P1 만 존재하므로 P1 이 스케줄 된다.
		- 1 시간에 P2 가 도착하고 P1 남은시간 > P2 이므로 P1 이 선점된다.
		- 5 시간까지 P2 가 가장 최단 작업이므로 P2 를 수행하고 P2 가 종료된다.
		- 남은 작업 중 가장 작은 잡업을 가진 것을 P4 이므로 P4 를 스케줄 한다.
		- P4 가 끝나고 P1 그 다음에 P3 순으로 스케줄을 한다.

### 5.3.3 우선순위 알고리즘 ( Priority Scheduling )
* CPU 는 가장 높은 우선운위를 가진 프로세스에게 할당
* 우선순위는 내부적/ 외부적으로 정의될 수 있다.
* 선점형/비선점형 모두 가능
	- 선점형일 경우 실행중인 프로세스보다 높은 우선운위 프로세스가 나타나면 새로운 프로세스가 CPU 를 점유한다.
* 단점
	- 선점형 우선순위 알고리즘의 경우, 낮은 우선순위 프로세스들이 CPU 를 무기한 대기하는 경우가 발생 

#### 용어
* 기아 현상 ( Starvation )
	- 낮은 우선순위 프로세스들이 CPU 를 무기한 대기하는 경우
* 노화 ( aging )
	- 오랜 시간 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시킨다.
	- 선점형 우선순위 알고리즘에서, 낮은 우선순위 프로세스들이 CPU 를 무기한 대기하는 걸 방지하기 위한 방법


### 5.3.4 라운드 로빈 스케줄링 ( Round Robin Scheduling : RR )
* 시간 할당량 또는 시간 조각이라는 작은 단위의 시간을 정의하여, CPU 스케줄러가 준비완료 큐를 돌면서
한 번에 한 프로세스에게 정해진 시간만큼 CPU 를 할당하는 방식
	- 할당된 시간이 끝나면 인터럽트를 걸더록 타이머를 설정한 후  프로세스를 디스패치 한다.
	- CPU 버스트 < 시간 할당량 : CPU 를 자발적으로 방출, 다음 프로세스를 실행
	- CPU 버스트 > 시간 할당량 : 인터럽트로 인해 Context Switching 발생, 준비완료큐 꼬리에 PCB 추가.
* 어느 프로세스도 연속으로 두 번 이상의 시간 할당량을 받을 수 없다 ( 유일한 프로세스가 아니라면 )
* 선점형 방식
* RR 알고리즘은 시간 할당량에 크게 영향을 받는다.
	- 시간 할당량이 매우 크면 FCFS 와 동일한 방식.
	- 시간 할당량이 매우 적으면 라운들 로빈 방식은 Processor sharing 이라 불리며, 
	이론적으로는 n 개의 프로세스들 각각이 실제 처리기의 1/n 의 속도로 
	실행되는 자신의 처리기를 가지는 첫처럼 사용자에게 보인다.
* 결국 총처리 시간은 시간 할당량 크기에 좌우된다.
	- 시간 할당량이 너무 작으면 Context Switching 이 자주 발생하고 너무 크면 FCFS 와 동일해져
	평균 대기시간이 길어질 수 있다.

##### 시간 할당량에 따른 문맥 교환 횟수
![5.4]( https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/cahp5-rr.png )

### 5.3.5 다단계 큐 스케줄링 ( Multilevel Queue Scheduling )
* 준비완료 큐를 다수의 별도 큐로 분리하고, 각 큐별로 우선순위를 가지고 스케줄링.
	- 현재 CPU 를 할당받은 프로세스보다 높은 우선순위를 가지는 프로세스가 
	준비완료 큐에 들어가면 기존에 있던 프로세스는 선점 될 것이다.
	- 큐의 우선순위에 따라 CPU 시간 할당량을 정하는 방식도 있다.
* 각 큐는 낮은 우선순위 큐보다 절대적인 우선순위를 가진다.
* 각 큐별로 서로 다른 스케줄링 알고리즘이 사용될 수 있으며 큐 사이에도 스케줄링이 존재한다.
* 우선 순위
	1. 시스템 프로세스
	2. 대화형 프로세스
	3. 대화형 편집 프로세스
	4. 일괄처리 프로세스
	5. 학생 프로세스
* ex ) 시스템 프로세스가 모두 비어있지 않으면 그 아래 프로세스들은 실행될 수 없다.
	- 각 큐에 할당된 프로세스는 큐 사이를 이동하지 않는다. => 우선순위 변동이 없다.

##### 다단계 큐 스케줄링
![5.6]( http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling_files/image013.jpg )
- 출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling.htm


### 5.3.6 다단계 피드백 큐 스케줄링 ( Multilevel Feedback Queue Scheduling )
* 다단계 큐 스케줄링과 다르게 프로세스가 큐 사이를 이동 가능하다. => 우선순위 변동이 가능하다
	- 어떤 프로세스가 CPU 시간을 너무 많이 잡아먹으면 낮은 순위 큐로 이동한다.
		- 반대로 입출력이나 대화용 프로세스는 높은 우선순위를 받아 서비스를 빨리 받는다.
	- Aging 을 적용하여 기아 현상을 방지한다.
* ex ) 스케줄러는 처음에 큐 0 에 있는 모든 프로세스들을 실행.
	- 큐 0 이 다 비었을 때 큐 1 에 있는 프로세스들을 실행.
	- 만약 큐 0 의 프로세스가 시간 할당량 안에 끝나지 않는다면, 큐 1의 꼬리로 이동

##### 다단계 피드백 큐
![5.7](http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling_files/image015.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring11/lectures/Scheduling.htm


## 5.4 스레드 스케줄링
* 스케줄 대상은 커널 수준 스레드이다.
	- 사용자 수준 스레드느 스레드 라이브러리에 의해 관리되고 커널은 그 존재를 알지 못하기 때문에
	CPU 상에서 실행되기 위해서 LWP 를 통한 간접적인 방식으로 커널 수즌 스레드에 매핑해아 한다.

### 5.4.1 경쟁 범위
* PCS ( Process Contention Scope )
	- 사용자 수준 스레드들이 동일한 프로세스에 속한 스레드들 사이에서 경쟁하는 것을 뜻함
	- 사용자 수준 스레드를 가용한 LWP 상에 스케줄 한다는 것은,
	스레드가 실제로 CPU 상에서 실행 중이라는 것을 의미하지 않는다.
		- 실제로 CPU 상에서 실행되기 위해서는 운영체제가 커널 스레드를 물리적인 CPU 로 스케줄 해야한다.
* SCC ( System Contention Scope )
	- CPU 상에서 어느 커널 스레드를 스케줄 할 것인가 결정하기 위한 경쟁 범위
* 사용자 수준 스레드의 우선순위는 프로그래머에 의해서 지정된다.


## 5.5 다중 처리기 스케줄링

### 5.5.1 다중 처리기 스케줄링에 대한 접근 방법
* 비대칭 다중 처리 ( Asymmetric Multiprocessing )
	- 주 서버라는 하나의 처리기가 모든 스케줄링과 입출력, 다른 시스템의 활동을 처리
	- 다른 처리기는 사용자 코드만을 실행
	- 자료 공유의 피료성이 감소되어 간단하다.
* 대칭 다중 처리 ( Symmetrit Multiprocessing )
	- 각 처리기가 독자적으로 스케줄링
	- 모든 프로세스는 공동의 준비 완료 큐에 있거나 사유의 준비완료 큐에 있음
	- 두 처리기가 같은 프로세스를 선택 하지 않고, 
	프로세스들이 큐에서 사라지지 않는 것을 보장해야 한다.


### 5.5.2 처리기 친화성 ( Processor Affinity )
* SMP 시스템에서 한 처리기에서 다른 처리기로 이주를 피하고
같은 처리기로 처리하려는 것을 뜻한다.
* 프로세스가 특정 처리기에서 실행 중일 때 캐시에서 발생하는 일.
	- 프로세스가 특정 처리기에서 실행 중일 때, 캐시에는 처리기에 의해 가장 최근에 접근한 데이터가 그 처리기의 캐시를 채우게 된다.
	- 따라서 프로세스에 의한 잇따른 메모리 접근이 캐시 메모리에서 만족하게 된다.
		- 만약 프로세스가 다른 처리기로 접근한 다면 캐시를 무효화 하고 캐시를 다시 채워야 한다.
* 운영체제의 스케줄러와 메모리 배치 알고리즘이 연동해서 동작한다면,
	특정 CPU 와 친화성을 갖는 프로세스는 그 CPU 가 장착된 보드 상의 메모리에 할당될 수 있다.

#### 용어
* NUMA ( Non Uniform Memory Access )
	- 비균등 메모리 접근
	- CPU 가 주 메모리의 일부분에 접근할 때 다른 부분보다 빠르게 접근하게 된다.
	- 통산 CPU 와 메모리가 합쳐진 보드를 사용하는 시스템에서 나타난다.
		- 보드의 CPU 는 같은 보드상의 메모리를 다른 보드의 메모리 보다 빠르게 접근 가능하다.

##### NUMA 의 메모리 접근
![5.9](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/Chap5-Numa.png)


### 5.5.3 부하 균등화 ( Load Balancing )
* SMP 시스템에서 모든 처리기 사이에 부하가 균등하게 배분되도록 한다.
* 공통의 준비완료 큐가 있는 시스템에서는 시스템의 한 처리기가 쉬고 있으면
공통 큐에서 프로세스를 선택하여 부하 균등화가 필요하지 않지만,
	사유의 준비완료 큐가 있는 경우 부하 균등화가 필요로 한다.
* PUSH 이주
	- 특정 태스크가 주기적으로 각 처리기의 부하를 검사하고,
	불균등한 상태라면 프로세스를 PUSH 함으로서 부하를 분배
* PULL 이주
	- 쉬고 있는 처리기가 바쁜 처리기를 기다리고 있는 프로세스를 가져온다.

#### 부하 균등화와 처리기 친화성은 상충된다.
* PUSH, PULL 이주를 통해 처리기를 옮김으로서 캐시의 이점을 무효화 한다.
* 어떤 정책이 최선이라고 하는 점에 대한 규칙은 없다.


### 5.5.4 다중코어 프로세서
* 하나의 물리적인 칩 안에 여러개의 처리기 코어가 장착된 프로세서
* 각 코어는 레지스터 집합을 가지고 있으며, 
	운영체제 입장에서는 별개의 처리기로 인식한다.
* 다중 코어는 하나의 코어보다 저전력 고성능을 보인다.

#### 다중 코어에서의 스케줄링
* 메모리 멈춤 ( Memory Stall )
	- 처리기가 데이터에 접근할 때 데이터가 가용해지기를 기다리면서 많은 시간을 허비하는 상황
		- 캐시 미스 등의 여러 원인으로 인해 발생

##### 메모리 멈춤
![5.10](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/chap5-memorystall.png)
* 메모리로부터 데이터가 가용해지길 기다리면서 약 50% 까지 시간을 허비
* 이에 대한 해결책으로 둘 또는 그 이상의 하드웨어 스레드가 
각 코어에 할당될 수 있는 다중 스레드 프로세서 코어를 구현

##### 다중 스레드 다중 코어 시스템
![5.11](https://github.com/martinkang/Study/blob/master/OSConcepts/ProcessManagement/img/chap5-memorystall2.png)
* 다중 스레드 다중 코어 시스템
	- 한 스레드가 메모리를 기다리다 멈추면, 코어는 다른 스레드로 전환할 수 있다.
* 다중 스레드화 하는 방법
	- 크게 나눔 ( coarse grained ) 다중 스레딩
		- 스레드가 메모리 멈춤과 같은 긴 지연시간을 가진 사건이 발생할 때까지 한 처리기에서 실행
		- 그러나 그 프로세서 코어에서 다른 스레드가 실행되기 전에 명령어 파이프 라인이 완전히 정리되어야 
	하므로 스레드간 교환 비용이 크다.
		- 이 새로운 스레드가 실행을 시작하게 되면 자신의 명령어들로 파이프라인을 채우기 시작한다.
	- 잘게 나눔 ( fine grained ) 다중 스레딩
		- 보통 명령어 주기의 경계에서와 같이 좀 더 세밀한 정밀도를 가진 시점에서 스레드 교환
		- 잘게 나눔 시스템 설계는 스레드 교환 회로가 포함되어 스레드 교환비용이 작다.

#### 왜 다중 스레드 다중 코어에서 하드웨어 스레드 전환은 메모리 멈춤을 유발하지 않는가?
* 기본적으로 컨텍스트 스위칭은 작업을 하던 컨텍스트를 어딘가에 저장해 둬야 하기 때문에 비용이 발생한다.
	- 레지스터 값은 컨텍스트 스위칭 시에 무효화 되어다가 다시 복구가 된다. 
* 하드웨어 스레드는 문맥 교환시에 캐시에 내용을 복제하는 레지스터를 가지고 있어서 컨텍스트 스위칭이 일어나도
동시에 여러 스레드의 컨텍스트를 유지할 수 있다.
	- 하드웨어 차원이 지원
	- 따라서 하드웨어 스레드는 컨텍스트 스위칭 시 물리 메모리 까지 접근하지 않아도 되기 때문에 더 효율적이다.
