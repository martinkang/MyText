# 1. 서론

## 운영체제의 정의
* 컴퓨터의 기동과 함께 핵심부(kernel)가 주기억 장치에 올려져 컴퓨터를 작동시키고
운영을 관리하여 응용 프로그램이 효율적으로 실행될 수 있는 환경을 제공하는 기본 소프트웨어

##### 컴퓨터 시스템 구성요소에 대한 개략적 구성도
![1.1](http://www.cs.odu.edu/~cs471w/spring10/lectures/introduction_files/image002.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring10/lectures/introduction.htm


## 컴퓨터 시스템의 구성

##### 현대의 컴퓨터 시스템
![1.2](http://www.cs.odu.edu/~cs471w/spring10/lectures/introduction_files/image004.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring10/lectures/introduction.htm
* 현대의 범용 컴퓨터는 공용 메모리에 대한 접근을 제공하는 공통 버스를 통해 연결된 여러개의
장치 제어기와 하나 이상의 CPU 로 구성되어 있다.
	- CPU 와 장치 제어기는 메모리 사이클을 얻기 위해 경쟁하면서 병행 실행된다.
	- 공유 메모리에 대한 질서 있는 접근을 보장하기 위해 메모리 제어기가 제공된다.
		- 메모리 제어기 : 메모리 접근을 동기화시킨다.


###### 부트스트랩
* 컴퓨터가 구동을 시작하기 위해서는 실행초기 프로그램이다.
* 전형적으로 부트스트랩은 보통 펌웨어라고 알려져 있는 컴퓨터 내의 ROM 이나 EEPROM 에 저장된다.
	- CPU 레지스터로부터 장치 제어기, 메모리 내용 등을 포함한 시스템의 모든 면을 초기화 한다.
* 부트 스트랩은 운영체제의 커널을 찾아 메모리에 적재한다.
* 이후 운영체제는 "init"와 같은 첫 번째 프로세스를 실행한다.



#### 용어
* 커널 ( Kernel )
		- 운영체제는 컴퓨터에서 항상 실행되는 프로그램으로 커널이라고도 불린다.
* 인터럽트 ( Interrupt )
		- 하드웨어나 소프트웨어에서 어떤 사건이 발생했음을 알리는 신호
			- 하드웨어는 어느 순간이던 시스템 버스를 통해 CPU 에 신호를 보내 인터럽트 발생 가능
			- 소프트웨어는 System Call 을 통해 인터럽트 발생
		- CPU 가 인터럽트 되면 하던 일을 중지하고, 즉시 고정된 위치로 실행을 옮긴다.
			- 이 고정된 위치에는 인터럽트 서비스 루틴이 위치한 시작 주소를 가지고 있다.
				- 인터럽트 서비스 루틴이 호출. 이 루틴은 인터럽트 고유의 handler 를 호출한다.
				- 사용 가능한 인터럽트의 수가 미리 정의되어있으므로 이 인터럽트 루틴에 대한 포인터들의 테이블을 이용할 수 있다.
					- 이 포인터 테이블에는 여러 장치에 대한 인터럽트 서비스 루틴이 주소가 들어있다.
			- 인터럽트가 완료되면 전에 하던 연산을 재개
		- 인터럽트 구조는 인터럽트된 명려으이 주소를 반드시 저장해야 한다.
			- 최근의 구조들은 시스템 스택에 복귀 주소를 저장한다.
			- 인터럽트 루틴은 반드시 명시적으로 현재의 상태를 저장하여야 한다.
			- 또한 복귀하기 전에 상태를 복원하여 인터럽트에 의해 중단되었던 연산이 인터럽트가 발생되지 않았던 것처럼 다시 시작.


##### 출력을 실행하고 있는 단일 프로세스에 대한 인터럽트 시간 일정
![1.3](https://github.com/martinkang/Study/blob/master/OSConcepts/Overview/img/chap1-interrupt.png)


## 저장장치 구조
* CPU 는 오직 메모리로부터 명령을 적재할 수 있으며,
	실행하고자 하는 프로그램은 모두 메모리에 저장되어야 한다.
* 범용 컴퓨터는 대부분의 프로그램을 주 메모리에서 실행시킨다.
* 모든 형태이ㅡ 메모리는 워드의 배열을 제공한다.
	- 적재 : 주 메모리로부터 CPU 내부의 레지스터로 한 워드를 옮긴다.
	- 저장 : 레지스터의 내용을 주 메모리로 옮긴다.
* 이상적으로 프로그램과 데이터가 주 메모리에 영구히 존재하기를 원하지만 다음과 같은 이유로 불가능하다.
	1. 주 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에 너무 작다.
	2. 주 메모리는 전원이 공급되지 않으면 그 내용을 읽어버리는 휘발성 저장장치이다.
* 따라서 대부분의 컴퓨터 시스템은 주 메모리의 확장으로 보조 저장장치를 제공한다.

#### 용어
* RAM ( Random Access Memory )
	- 읽기 쓰기 가능한 메모리
	- 주메모리 라고 불린다.
* ROM ( Read Only Memory )
	- 읽기 전용 메모리

##### 저장장치 계층
![1.4](http://www.cs.odu.edu/~cs471w/spring10/lectures/introduction_files/image007.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring10/lectures/introduction.htm
* 상위 수준은 가격이 비싸지만 빠르다. 휘발성이다
* 하위 수준은 느리지만 용량이 크고 비휘발성이다..


## 입출력 구조
* 장치 제어기 ( Device Controller )
	- 자신이 제어하는 주변장치와 자신의 로컬 버퍼 저장장치 사이의 데이터 전송을 담당
	- 통상적으로 운영체제는 각 장치 제어기마다 디바이스 드라이버를 가지고 있다.
	- 특정 타입의 장치를 담당
	- 장치 제어기에 따라 하나 이상의 장치가 부착될 수 있다.
	- 약간의 로컬 버퍼 저장장치와 특수 목적용 레지스터 집합을 유지한다.
* 입출력 연상 과정
	- 입출력 연산을 시작하기 위해 디바이스 드라이버는 장치 제어기의 적절한 레지스터에 필요한 값을 적재한다.
	- 장치 제어기는 이어 취할 동작을 결정하기 위해 이들 레지스터의 내용을 조사한다.
		- ex ) 키보드에서 한 문자를 읽어라
	- 제어기는 장치로부터 자신의 로컬 버퍼로 데이터 전송을 시작한다.
	- 데이터 전송이 완료되면, 장치 제어기는 자신이 연산을 완료했음을
	인터럽트를 이용하여 디바이스 드라이버에 통보한다.
	- 디바이스 드라비어는 제어를 운영체제에게 반환한다.
		- 입력 완료일 경우 데이터를 반환하거나 다른 동작에 대해서는 디바이스 드라이버 상태 정보를 반환한다.
* DMA( Direct Memory Access )
	- 인터럽트 구동 방식의 입출력은 적은 양의 데이터를 전송하는 데에는 문제가 없으나
	디스크 입출력과 같은 대량의 데이터를 전송하는 데에는 높은 오버헤드를 초래한다.
		- 데이터를 일정량 보낼때마다 인터럽트를 발생시키면 오버헤드가 발생한다.
	- 장치 제어기는 CPU 의 개입 없이 메모리로부터 자신의 버퍼 장치로 또는 버퍼로부터
	메모리로 데이터 블록 전체를 전송하고, 블록 전송이 완료될 때마다 인터럽트를 발생한다.
		- 블록 전송을 하는 동안 CPU 는 다른 작업을 할 수 있다.

##### 현대 컴퓨터 시스템의 동작
![1.5](http://www.cs.odu.edu/~cs471w/spring10/lectures/introduction_files/image009.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring10/lectures/introduction.htm


## 컴퓨터 시스템 구조

##### 대칭적 다중처리 구조
![1.6](https://github.com/martinkang/Study/blob/master/OSConcepts/Overview/img/chap1-smp.png)

### 하나의 칩에 두 개의 코어가 장착된 이중 코어 설계
![1.7](https://github.com/martinkang/Study/blob/master/OSConcepts/Overview/img/chap1-dualcore.png)


## 운영체제의 구조

##### 다중 프로그래밍 시스템을 위한 메모리 배치
![1.8](https://github.com/martinkang/Study/blob/master/OSConcepts/Overview/img/chap1-memory-layout.png)


## 운영체제 동작
* 현대의 운영체제는 인터럽트 구동식이다.
* 운영체제와 사용자는 컴퓨터 시스템의 하드웨어와 소프트웨어 자원을 공유하기 때문에
사용자 프로그램의 오류가 현재 실행 중인 프로그램에만 문제를 일으키도록 보장해야 한다.

#### 용어
* 인터럽트 구동식 ( Interrupt Driven )
	- 서비스할 입출력 장치도 없고, 실행할 프로세스도 없다면 운영체제는
	무엇인가 일어나기 조용히 기다리다가 인터럽트나 트랩에 의해 깨어난다.
* 트랩 ( trap )
	- 오류 ( 예를 들어 0 으로 나누기 도는 유효하지 않은 메모리 접근 ) 또는 사용자 프로그램의
	운영체제 서비스 실행 요청에 의해 유발되는 소프트웨어에 의해 생성되는 인터럽트


### 이중 동작 모드 ( Dual Mode Operation )
* 운영체제의 적절한 동작을 보장하기 위해 운영체제 코드의 실행과 사용자 정의 코드의 실행을 구분할 수 있어야 한다.
	- 많은 운영체제가 선택하는 접근 방법은 여러 실행 모드를 구분할 수있도록 지원하는 하드웨어를 이용하는 것이다.
* 이중 동작 모드
	* 모드 비트 ( Mode bit )
		- 운영체제를 위하여 실행되는 작업과 사용자를 위해 실행되는 작업을 구분 하기 위한 비트
		- 커널모드 ( 0 ), 사용자 모드 ( 1) 을 나타냄
	* 모드
		- 커널 모드 ( Kernel Mode ), 시스템 모드, 특권 모드 ( Privileged mode )
			- 운영체제를 위하여 실행되는 작업을 실행할 때.
			- 시스템 자원, 하드웨어 을 사용하거나 시스템 콜 등의 작업을 할 때
			- 트랩이나 인터럽트, 시스템 콜 등이 발생할 때 변경됨
		- 사용자 모드 ( User Mode )
			- 사용자 어플리케이션을 위하여 실행 될 때
	* 동작
		- 트랩이나 인터럽트가 발생할 때마다 하드웨어는 사용자 모드에서 커널 모드로 전환
		- 운영체제가 컴퓨터의 제어를 얻을 대마다 항상 커널 모드에 있게 된다.
		- 시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드로 전환한다.
	* 이점
		- 악 영향을 끼칠 수 있는 일부 명령을 특권 명령으로 지정함으로서 보호할 수 있다.
			- 사용자 모드에서 특권 명령을 실행하려고 시도하면, 불법적인 명령으로 간주해 운영체제로 트랩은 건다.

##### 사용자 모드에서 커널 모드로의 전환
![1.10](http://www.cs.odu.edu/~cs471w/spring10/lectures/introduction_files/image011.jpg)
- 출처 http://www.cs.odu.edu/~cs471w/spring10/lectures/introduction.htm


### 타이머
* 지정된 시간 후 컴퓨터를 인터럽트하도록 설정.
	- 운영체제가 CPU 에 대한 제어를 유지할 수 있도록 보장해야 한다.
		- 사용자 프로그램이 무한 루프에 빠지거나, 시스템 서비스를 호출하지 않아서 제어가 운영체제로
	복귀하지 않는 경우를 허용할 수 없다.
* 타이머의 동작을 변경하는 명령은 특권 명령이다.


### 캐싱 ( Caching )
* 특정 정보가 필요할 경우 먼저 캐시에 그 정보가 있는지 조사하고, 캐시에 있으면 그 정보를 캐시로부터 가져오고
없다면 주 메모리 시스템으로부터 그 정보를 가져와야 한다.
	- 캐시에서 가져오는 것이 메모리 에서 가져오는 것보다 훨씬 빠르기 때문에 성능 향상에 도움이 된다.
	- 한번 가져온 정보는 다시 사용될 확률이 높다는 가정하에 캐시에 넣어둔다.
		=> 이와 같이 한번 가져온 정보를 다음에 다시 필요로 할 때 고속의 캐시에 넣어
		빠르게 읽어들이는 것을 캐싱이라고 한다.
* 데이터가 이동하는 순서
	- 디스크 => 주 메모리 => 캐시 => 하드웨어 레지스터
* 캐시 일관성 문제
	- 메모리 계층 구조에서 동일한 데이터가 동시에 서로 다른 수준의 저장장치 시스템에 나타나게 된다.
		- 멀티 프로세서에서는 각 프로세서 마다 로컬 캐시를 가지고 있어 각 캐시에 동일한 데이이터의 복사본이 존재할 수 있다.
		- 한 프로세서에서 이 복사본이 수정될 경우 모든 프로세서의 캐시에 즉각적으로 변경되어야 한다.

##### 캐시 일관성 문제
![1.9](https://github.com/martinkang/Study/blob/master/OSConcepts/Overview/img/cahp1-cache.png)
