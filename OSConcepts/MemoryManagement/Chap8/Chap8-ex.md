# 연습문제
* 1. 내부 단편화와 외부 단편화 사이의 차이점을 설명하시오
	* 정의
		- 외부 단편화
			- 만약에 메모리를 가변 크기로 나누어 할당한다면, 여러 프로세스가 할당/해제를 반복됨에 따라 사용 가능한 연속된 메모리가 
			자잘하게 나누어 존재하게 되는 단편화가 발생한다.
			- 이 경우 단편 조각들의 총합은 커도, 개별적인 조각들의 메모리 가용 사이즈가 커 사용할 수 없다.
		- 내부 단편화
			- 만약에 메모리를 고정된 크기로 나누어 할당한다면, 프로세스가 만약 이 고정된 크기의 메모리의 배수배보다 작다면,
			이 남은 공간은 낭비된다.
	* 차이점
		- 외부 단편화는 연속된 메모리가 작게 나누어져 사용할 수 없어 낭비되는 현상이고, 
		내부 단편화는 프로세스가 할단된 메모리보다 크기가 작아 메모리가 낭비되는 현상이다.
* 2. 다음 이슈들의 관점에서 연속적 메모리 할당, 순수 세그먼테이션, 순수 페이징 기법들을 비교하시오.
	* 외부 단편화
		- 연속적 메모리 할당
			- 프로세스에서 요청한 크기에 맞게 할당하므로 가변적으로 메모리가 할당되고, 외부 단편화가 발생하지 않는다.
		- 순수 세그먼테이션
			- 세그먼트마다 각 크기가 다르게 할당되므로 외부 단편화가 발생한다.
		- 순수 페이징
			- 페이징은 고정된 크기로 메모리를 할당하기 때문에 외부 단편화가 발생하지 않는다.
	* 내부 단편화
		- 연속적 메모리 할당
			- 발생하지 않음
		- 순수 세그먼테이션
			- 발생하지 않음
		- 순수 페이징
			- 곶어된 크기로 메모리를 할당하기 때문에 마지막에 할당한 페이지의 경우 내부적으로 단편화가 발생한다.
	* 프로세스 사이의 코드 공유 가능성
		- 연속적 메모리 할당
			- 하나의 프로세스에 대해서 연속된 메모리를 한번에 할당 하므로, 
			부분적으로 코드 공유가 불가능하다. 
		- 순수 세그먼테이션
			-  세그먼트마다 따로 할당이 되므로, 다른 프로세스가 물리메모리에 있는 세그먼트를 
			세그먼트 테이블에 사상함으로써 코드 공유가 가능하다.
		- 순수 페이징
			-페이지마다 따로 할당이 되므로, 서로 다른 프로세스가 물리메모리에 있는 페이지를
			페이지 테이블에 사상함으로써 코드 공유가 가능하다
* 3. 세그먼테이션과 페이징 기법을 결합하여 사용하는 이유는?
	- 페이지화 세그먼테이션 ( Segmentation with Paging )
		- 페이징 기법과 세그멘테이션 기법을 혼합
			- 세그먼트가 있고 이는 다시 더 작은 단위인 페이지로 나누는 방식
			- 세그멘테이션 기법과 2 단계 페이징을 사용하여 주소를 찾아가는 방법.
			- 4KB, 2MB 그리고 4MB 사이즈로 페이징.
			- 코드, 데이터, 힙, 스텍등의 logically 관련있는 유닛들을 관리할 때는 세그먼트를 사용.
		- 서브루틴, 힙 영역 등을 세그먼트로 나누고 그 세그먼트들을 페이징 기법으로 물리메모리에 매핑시켜주면,
		페이지 테이블이 비정상적으로 커지는 것을 막을 수 있고, 
		홀을 없앰으로써 외부 단편화로 인해 발생하는 메모리 공간을 낭비하는 것도 막을 수 있다.
* 4. 대부분의 시스템은 실행 중에 프로그램이 자신의 주소 공간에 메모리를 추가로 할 당하는 것을 지원하고 있다.
프로그램의 힙 세그먼트에 할당된 데이터는 이렇게 할당된 메모리의 예라고 할 수 있다.
다음 기법들에서 동적 메모리 할당을 지원하기 위해서 어떤 것들이 요구되는가?
	- 연속 메모리 할당
		- 동적으로 할당될 메모리 크기 만큼의 연속된 메모리 공간
	- 순수 세그먼테이션
		- 할당할 각각의 세그먼트보다 할당이 가능한 메모리 공간.
	- 순수 페이징
		- 할당되지 않은 페이지들의 총합이 할당할 메모리 크기보다 커야한다.
* 6. 페이지 테이블을 페이징 하는 목적은 무엇인가?
	- 만약 64 bit 머신이라고 할 때 표현가능한 주소는 2^64 이다. 각 페이지가 4KB ( 2^12 ) 라고 가정하면  
	나머지 공간 ( 즉 페이지 테이블의 크기 ) 는 2^48 이 된다. 
	이는 매우 큰 크기로 원하는 페이지를 찾을때까지 걸리는 시간도 길어지지만, 각 프로세스마다 2^48 만큼의
	공간을 페이지 테이블로 가지게 되므로 공간낭비가 심하다.
		- 따라서 페이지 테이블을 페이징 하는 목적은 페이지 테이블의 크기를 줄여 탐색 의 효율성 및
		공간 절약을 하는 것을 목적으로 한다.
* 7. 순수 페이징보다 세그먼테이션을 사용하여 재진입(reentrant) 모듈을 공유하는 것이 쉬운 이유를 설명하시오.
	- 세그먼테이션은 논리 구조 공간을 하나의 세그먼트로 정의하므로 하나의 모듈이 한 세그먼트에 있어
	공유하는게 더 쉽지 않을까?
		- 순수 페이징은 한 모듈이 여러 페이지에 나눠질 수 있어서?
* 8. 페이징 시스템에서 프로세스가 자신이 소유하지 않은 메모리에 접근할 수 없는 이유?
운영체제는 어떻게 다른 메모리에 대한 접근을 허용하는가? 허용한다면 그 이유는 무엇이며,
	안 한다면 그이유가 무엇인가?
	* 페이징 시스템에서 프로세스가 자신이 소유하지 않은 메모리에 접근할 수 없는 이유
		- 페이징은 페이지 테이블을 이용하여 실제 물리 메모리에 있는 페이지에 접근하므로,
		이 페이지 테이블은 해당 프로세스가 소유한 페이지의 주소만 가지고 있으므로
		소유하지 않은 메모리는 접근할 수 없다.
	* 운영체제는 어떻게 다른 메모리에 대한 접근을 허용하는가?
		- CPU 가 스케줄러에서 다음으로 실행할 프로세스를 선택할 때 디스패처는 문맥 교환의 일환으로
		재배치 레지스터와 상한 레지스터의 정확한 값을 적재한다.
		- CPU 에 생성되는 모든 주소들은 이 재배치 레지스터와 상한 레지스터를 이용하여 메모리 접근을 허용한다.
	* 허용하는 이유
		- 공유 메모리
	* 허용하지 않는 이유
		- 중요한 시스템 자원일 경우 권한에 따른 허용/거부
* 9. 큰 주소 공간을 관리하는 환경에서 세그먼트 페이징 기법과 해시 페이지 테이블 기법을 비교하시오.
어떤 상황에서 한 기법이 다른 기법보다 더 선호되는가?
	- 세그먼트 페이징 기법
		- 고정된 크기의 페이지와 논리적 집합인 세그먼트를 결합한 방식으로, 고정된 크기로 나눠
		선수 세그먼테이션에서 발생하는 외부 단편화 문제를 해결할 수 있고, 코드, 데이터, 힙, 스택등의
		논리적으로 관련있는 유닛들을 세그먼트로 관리함으로서 페이지 테이블의 지나친 증가를 막을 수 있다.
	- 해시 테이블 기법
		- 해시 함수를 이용하여 가상 페이지 번호를 해싱하고, 해당 해시갑과 연결리스트의 값을 비교 탐색하는 방법
			- 클러스터 페이지 테이블을 사용할 경우, 한 개의 페이지 테이블 항목이 여러 페이지 프레임에 대한 
			변환 정보를 지닐 수 있다.
	- 어떤 상황에서 한 기법이 다른 기법보다 더 선호되는가?
		- 메모리 엑세스가 비연속적이면서 전체 주소 공간에 넓게 흩어져 있는 경우
			- 해시 테이블 기법 ( 클러스터 페이지 테이블 )
			- 좀더 찾아볼것
* 10. 페이지 테이블을 메모리에 저장하는 페이징 시스템을 생각해보자.
	- 만약 메모리 참조가 200nsec 걸린다면 이 페이징 시스템에서 메모리 참조는 얼마나 걸리는가?
		- 200nsec
	- 만약 TLB 를 추가하고 모든 페이지 테이블 참조의 75% 를 TLB 에서 찾을 수 있다면
	유효 메모리 참조 시간은 얼마인가?
	( 단, TLB 에 페이지 항목이 있다면 페이지 테이블 항목을 찾는데 시간이 걸리지 않는다고 가정 )
		- 0.75 * 0 + 0.25 * 200 = 50nsec
* 11. 가상 주소를 물리 주소로 변환하는 주소 변환 구조가 필요로 하는 메모리 크기의 관점에서
페이징 기법과 세그먼테이션 기법을 비교하시오.
* 12. 프로그램이 코드와 데이터 두 분으로 나누어진 시스템을 고려하자. CPU 는 자신이 명령어( 면령어 반입 )
	또는 데이터( 데이터 반입 또는 저장)를 필요로 하는지 알고 있다. 따라서 명령어와 데이터 각각을 위하여
	두 쌍의 기준-한계 레지스터가 제공된다. 명령어 기준-한계 레지스터 쌍은 자동적으로 읽기전용으로
	설정되므로 프로그램은 사용자들 사이에 공유될 수 있다. 이 기법의 장점과 단점을 논의하시오.
* 13. 다음은 이진 파일을 만드는 과정을 설명한 것이다. 컴파일러는 각각의 모듈에 대한 목적 코드를
생성하고 연결 편집기는 여러 개의 모듈을 하나의 이진 프로그램으로 조합한다.
연결 편집기가 어떻게 명령어와 데이터들의 메모리 주소에 대한 바인딩을 변경시키는가?
연결 편집기의 메모리 바인딩 작업을 원할하게 실행하기 위해서 컴파일러는 연결 편집기로 어떤 정보가
전달되어야 하는가?
	- 연결 편집기가 어떻게 명령어와 데이터들의 메모리 주소에 대한 바인딩을 변경시키는가?
	- 연결 편집기의 메모리 바인딩 작업을 원할하게 실행하기 위해서 컴파일러는 연결 편집기로 어떤 정보가
	전달되어야 하는가?연결 편집기의 메모리 바인딩 작업을 원할하게 실행하기 위해서 컴파일러는 
	연결 편집기로 어떤 정보가 전달되어야 하는가?
		- 원시 프로그램에서 주소는 숫자가 아닌 심벌 형태로 표현 되기 때문에, 
	- 모르겠다... 책에도 제대로 안나왔으면서....
* 14. 한 페이지가 1024 워드 크기인 64 페이지로 구성된 논리 주소공간을 고려하자. 
이 공간은 32 프레임의 물리 주소공간으로 사상된다. ( 1 word = 2 byte 로 계산 )
	- 논리 주소는 몇 비트로 구성되는가?
		- 64 page = 2^6
			- 6 bit
	- 물리 주소는 몇 비트로 구성되는가?
		- 1024 word == 512 byte = 2^9 * 2^3 bit = 2^12 bit.
			- 12 bit
* 16. 최초 접합, 최적 접합, 최악 접합 알고리즘 정의
	- 최초 접합
		- n 바이트의 메모리를 할당할 때 n 보다 큰 할당가능한 메모리 공간을 찾았을 경우 해당 메모리 공간을
		n 만큼 할당한다.
	- 최적 접합
		- n 바이트 메모리를 할당하려고 할때 가장 n 바이트와 가까운 메모리 공간을 찾고 n 바이트만큼 할당한다.
	- 최악 접합
		- 할당하려는 메모리와 상관없이 가장 큰 메모리 공간을 찾아 할당 요청한 만큼 할당 해준다.
		- 할당을 해주고 남은 공간도 충분히 크기 때문에 다른 프로세스에 할당이 가능하지만,
		공간들이 크기순으로 정렬되있지 않으면 전체 리스트를 다 검색해야 한다.
* 17. 하나의 세그먼트가 두 개의 다른 프로세스의 주소 공간에 속할 수 있게 하는 기법을 설명하시오.
* 18. 32 비트 논리 주소와 4KB 페이지 크기를 갖는 컴퓨터 시스템을 고려하자. 이 시스템의
최대 512MB 의 물리 메모리를 장착할 수 있다. 다음 각 테이블에는 각가 몇 개의 항목이 존재하는가?
	- 전통적인 1 단계 페이지 테이블
		- 논리주소 32 bit, 물리주소 22 bit
	- 역 페이지 테이블
		- 논리주소 17 bit, 물리주소 22 bit
			- 512MB 는 2^39 로 역 페이지 테이블은 물리페이지에 대응되는 항목을 저장한다.
				- 즉 512MB 를 넘는 주소를 가르킬 수 없다.
			- 페이지 크기는 4KB 이므로 물리주소의 크기는 변화가 없지만, 
			논리주소 * 물리주소 = 512 MB  => 2^x * 2^22 ( 4KB ) = 2^39 ( 512MB ) 가 되야하므로
			논리주소는 17 bit 가 된다.
* 20. 많은 시스템에서 이진 프로그램은 다음과 같은 구조를 가지고 있다. 코드는 0과 같은 고정된
가상 주소부터 저장된다. 프로그램의 변수를 저장하는 데이터 세그먼트가 코드 세그먼트 다음으로 위치한다.
프로그램의 실행이 시작되면 스택은 가상 주소 공간의 반대편에 할당되고 주소가 작은 방향으로 
크기가 확장된다. 이러한 구조는 다음 메모리 관리 기법들에게 어떤 영향을 주는가.?
	- 연속 메모리 할당
	- 순수 세그먼테이션
	- 순수 페이징
* 23. 동적 연결 세그먼트 시스템에서는 프로세스들이 같은 세그먼트 번호를 사용하지 않더라도
세그먼트를 공유하는 것이 가능하다.
	- 같은 세그먼트 번호를 사용하지 않고 세그먼트를 공휴할 수 있는 정적 연결 시스템을 정의하시오
	- 같은 페이지 번호를 사용하지 ㅇ낳고 페이지를 공휴할 수 있는 페이지 기법을 설명하시와.
* 24. 주소 공간 식별자(ASIDs)가 필요한 이유를 설명하시오.
	- ASIDs 는 TLB 상에서 어떤 프로세스의 페이지 테이블인지 식벽하는 식별자로,
	만약 ASIDs 가 없다면, 새로운 페이지 테이블이 선택될 때마다 ( 예를들어 컨텍스트 스위칭 )
	TLB 의 모든 테이블을 플러시 해야한다.
		- 어느 프로세스의 페이지 테이블인지 알 수 없으므로 전부 플러시 하고 새로 저장해야 한다.
	- ASIDs 를 사용하면 TLB내에 여러 프로세스의 페이지를 저장가능하다.
