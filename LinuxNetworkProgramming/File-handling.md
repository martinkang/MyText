# 파일 처리 ( 저수준 파일 핸들링, 고수준 파일 핸들링 )

## 저수준 파일 핸들링
* 저수준 파일 핸들링이란 ?
	- 파일 기술자를 가지고 입출력을 한다.
* 저수즌 파일 핸들링의 특징
	- 파일 기술자 ( file descriptor ) 를 사용한다.
	- 오버헤드가 적고 버퍼링이 되지 않는다.
	- PIPE_BUF 이내의 길이에 대해서는 원자적( atomic ) 실행을 보장
	- 비 직관적이다.


## 고수준 파일 핸들링
* 고수준 파일 핸들링이란?
	- 파일 포인터(스트림) 을 이용해서 입출력 하는 방식
* 고수준 파일 핸들링의 특징
	- 버퍼링을 할 수 있다.
	- 원하는 형태로 포맷팅이 가능하다
	- 버퍼링의 경우에 플러쉬 ( flush ) 되는 시점에 따라서 원자적 실행을 보장 할 수 없다.

### 고수준 파일 핸들링의 사용
* 스트림( stream) 이란
	- 연속된 공간에서의 가상의 데이터 흐름을 지칭
	- 어떤 데이터가 어떤 장치를 거쳐서 몇 개의 나눠진 메모리에 저장된다고 했을 때
	이를 하나하나 쪼개진 데이터가 아닌 가상의 장치 위에서 연결된 하나의 흐름으로 본다.
	- 파일 포인터 FILE* 을 사용
* 버퍼링 ( buffering )
	-  작업은 데이터를 전송하는데 있어서 바로 목적지로 보내는 것이 아니라
	중간에 버퍼를 두어 전송하고자 하는 데이터를 임시로 저장해 두었다가, 그것이 어느 정도 차면 한꺼번에 데이터를 전송하는 것
	- 버퍼링은 지정하지 않으면 기본적으로 완전 버퍼링 ( Fully buffered, block buffering ) 으로 지정됨
		- 완전 버퍼링 : 버퍼에 일정한 블록 이상이 쌓이면 출력


> setvbuf ( File *stream, char *buffer, int mode, size_t size );
> - 스트림 버퍼링 방식을 변경한다.



## 저수준과 고수준 파일 입출력의 혼용
* 연결된 채널들 ( linked channels )
	- fd 를 dup(2) 하여 복제된 파일 기술자가 있거나 파일 스트림 포인터를 얻었을 때, 이들은 실제적으로 한 개의 채널을 공유하고 있으므로 모두가 같은 위치를 보고 있다.
	- 하나의 파일 기술자를 lseek() 을 통하여 이동할 경우 다른 파일 기술자나 스트림 포일터의 위치도 변경된다.
* 독립된 채널 ( independent channels )
	- 한 개의 파일에 대하여 중복적으로 파일을 열어도, 실제로는 두 개의 채널이 생기고 두 파일은 독립적인 파일 위치를 가진다.
	- 따라서 서로 입출력을 하더라도 영향을 받지 않는다.
	- 독립된 채널을 사용하여 여러 개의 스트림을 열고 쓸 경우에는 버퍼링된 스트림이 비워지는 시점에 따라서 데이터의 출력 시간이 조금씩 어긋날 수 있따.
		* 버퍼링을 사용하지 않으면 된다.
	




## 저수준 및 고수준 파일 핸들링의 차이

* 하나의 동일한 파일에 대해 파일 기술자와 파일 스트림을 병행적으로 사용하는 것은 피해야 한다.
	- 보통 스트림 이용시 버퍼링이 발생하게 되고, 이 버퍼링과 처리하는 작업의 우선순위가 의도한대로 작동하지 않을 수 있어 문제 발생의 소지가 있다.
* 원자성( atomic ) 과 쓰레드 - 안전( thread safe ), 재진입성( reentrant ) 에 대해서
	- 원자성이 보장되는 함수
		* 함수가 일단 시작하면, 종료하기 전에 이 함수의 기능에 영향을 줄 수 있는 다름 함수가 끼어들지 못한다.
	- 재진입성
		* 동일한 함수가 병렬적으로 호출되었을 때 서로 다른 공간을 가지므로 서로 크리티컬 섹션 문제와 같은 오염에 대한 걱정이 없음
	- 쓰레드 안전
		* 쓰레드 간에 서로 동시에 함수를 호출해도 문제가 발생하지 않도록 디자인됨.


## 그 외

* 버퍼 비우기

> fflush( FILE *stream )
> - 스트림 기반의 함수들에 의해서 버퍼에 쌓여 있는 모든 데이터를 강제로 출력시킨다. 
> - 버퍼공간에 쌓여있는 데이터가 없다면 아무런 일도 하지 않을 것이다.
> - 입력 버퍼링을 비우는 행위는 정의 되지 않았으므로 사용하지 말아야 한다.


* 예제
	- [flush.c](https://github.com/martinkang/Study/tree/master/LinuxNetworkProgramming/ex/flush.c)


```c++
char test1[10] ={0, };
char test2[20] = {0, };

fputs( "input test1 : ", stdout );
fgets( test1, 5, stdin );

fputs( "input test2 : ", stdout );
fgets( test2, sizeof( test2 ), stdin );

printf( "test1 : %s\n", test1 );
printf( "test2 : %s\n", test2 );
```
> 결과   
> 	- input test1 : 1234567  
> 	- input test2 : test1 : 1234  
> 	- test2 : 567  

> 입력 buffer  
> 	* | 1 | 2 | 3 | 4 | 5 | 6 | 7 | \n |   
> after fgets( test1, 5, stdin )   
> 	* | 5 | 6 | 7 | \n |   
> fgets( test2, sizeof( test2 ), stdin );  
> 사용자가 입력하지 않아도 이미 버퍼에 문자들이 남아있기 때문에 남아있는 문자역을 읽어들여 test2 에 저장한다.

```c++
char test1[10] ={0, };
char test2[20] = {0, };

fputs( "input test1 : ", stdout );
fgets( test1, 5, stdin );

while( getchar() != '\n' ); // 입력 버퍼를 비움

fputs( "input test2 : ", stdout );
fgets( test2, sizeof( test2 ), stdin );

printf( "test1 : %s\n", test1 );
printf( "test2 : %s\n", test2 );
```

* exec(3) 계열의 함수 또는 fork(2) 를 사용하는 경우에 기존 스트림 버퍼가 파괴되어 지므로, 스트림이 깨끗하게 비우는 것이 중요하다.
