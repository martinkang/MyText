# 파일 처리 ( 저수준 파일 핸들링, 고수준 파일 핸들링 )

## 저수준 파일 핸들링
* 파일 기술자 ( file descriptor ) 
* 오버헤드가 적고 버퍼링이 되지 않는다.
* PIPE_BUF 이내의 길이에 대해서는 원자적( atomic ) 실행을 보장
* 비 직관적


## 고수준 파일 핸들링
* 버퍼링을 할 수 있다.
* 원하는 형태로 모맷팅 가능
* 버퍼링의 경우에 플러쉬 ( flush ) 되는 시점에 따라서 원자적 실행을 보장 할 수 없다.

### 고수준 파일 핸들링의 사용
* 스트림( stream) 이란
	- 연속된 공간에서의 가상의 데이터 흐름을 지칭
	- 어떤 데이터가 어떤 장치를 거쳐서 몇 개의 나눠진 메모리에 저장된다고 했을 때
	이를 하나하나 쪼개진 데이터가 아닌 가상의 장치 위에서 연결된 하나의 흐름으로 본다.
	- 파일 포인터 FILE* 을 사용

* 버퍼링 ( buffering )
	-  작업은 데이터를 전송하는데 있어서 바로 목적지로 보내는 것이 아니라
	중간에 버퍼를 두어 전송하고자 하는 데이터를 임시로 저장해 두었다가, 그것이 어느 정도 차면 한꺼번에 데이터를 전송하는 것
	- 버퍼링은 지정하지 않으면 기본적으로 완전 버퍼링 ( Fully buffered, block buffering ) 으로 지정됨
		- 완전 버퍼링 : 버퍼에 일정한 블록 이상이 쌓이면 출력


> setvbuf ( File *stream, char *buffer, int mode, size_t size );
> - 스트림 버퍼링 방식을 변경한다.

* exec(3) 계열의 함수 또는 fork(2) 를 사용하는 경우에 기존 스트림 버퍼가 파괴되어 지므로, 스트림이 깨끗하게 비우는 것이 중요하다.



## 저수준과 고수준 파일 입출력의 혼용
* 연결된 채널들 ( linked channels )
	- fd 를 dup(2), dup2(2) 하여 복제된 파일 기술자가 있거나 파일 스트림 포인터를 얻었을 때, 이들은 실제적으로 한 개의 채널을 공유하고 있으므로 모두가 같은 위치를 보고 있다.
	- 하나의 파일 기술자를 lseek() 을 통하여 이동할 경우 다른 파일 기술자나 스트림 포일터의 위치도 변경된다.

* 독립된 채널 ( independent channels )
	- 한 개의 파일에 대하여 중복적으로 파일을 열어도, 실제로는 두 개의 채널이 생기고 두 파일은 독립적인 파일 위치를 가진다.
	- 따라서 서로 입출력을 하더라도 영향을 받지 않는다.
	- 독립된 채널을 사용하여 여러 개의 스트림을 열고 쓸 경우에는 버퍼링된 스트림이 비워지는 시점에 따라서 데이터의 출력 시간이 조금씩 어긋날 수 있따.
		* 버퍼링을 사용하지 않으면 된다.
	

> fflush( FILE *stream )
> - 스트림 기반의 함수들에 의해서 버퍼에 쌓여 있는 모든 데이터를 강제로 출력시킨다. 
> - 버퍼공간에 쌓여있는 데이터가 없다면 아무런 일도 하지 않을 것이다.
> - 입력 버퍼링을 비우는 행위는 정의 되지 않았으므로 사용하지 말아야 한다.

	- 여러 개의 스트림을 독립된 채널들로 구성할 때는 
	미쳐 비우지 못한 스트림 버퍼로 인해서 새로 열린는 스트림의
	예상되는 위치나 아직 버퍼링된 입력으로 인하여 쓸모없는
	데이터를 읽을 수 있으므로 스트림을 깨끗히 비우기 위해서
	fflush() 를 호출할 수 있다.
		* 입력 버퍼링을 비우는 fflush() 함수는 입력 버퍼에 대한 행위는 정의 되지 않았으므로 사용하지 말아야 한다

## 패딩( padding ) / 팩( pack ) 과 XDR



## 저수준 및 고수준 파일 핸들링의 차이


## 대용량 파일 지원( LFS )

