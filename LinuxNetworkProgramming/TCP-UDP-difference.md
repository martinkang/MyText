# TCP 와 UDP 비교
	- TCP 와 UDP 를 비교해보고 데이터의 분절처리, 효율성을 판단하는 기준 등에 대해 다뤄본다.

* 용어 정의
	* 데이터 ( data )
		- 우리가 실제로 전달하고자 하는 내용.
	* 데이터그램 ( datagram )
		- 이 데이터가 일정한 단위를 가진 경우.
		- UDP 에서는 유저가 데이터 단위를 나눴다고 해서 유저 데이터그램 이라고 한다.
	* 세그먼트 ( segment ), 세그먼트화 ( segmentation )
		- 데이터들이 조각으로 나눠진 부분들로 세그먼트화는 구획을 나누는 행위.
		- 세그먼트들과 원본 데이터는 정확한 경계와 집합의 성질을 가지지는 않는다.
		- 세그먼트로 나눈 조각을 모아 놓아도 원본 데이터 원본 데이터를 알 수 없다.
			- ex ) 30, 40, 50 의 세 덩어리를 15 씩 8조각으로 나눈 뒤, 이 세그먼트를 다시 모아도
			기존의 원본덩어리인 30, 40, 50 이였는지 알 수 없다.
	* 단편 ( fragment ), 단편화 ( fragmentation )
		- 단편은 원래 완성된 원본 데이터의 일부분으로, 원래 데이터를 재조홥하기 위해서 단편화를 행한다.
		- 세그먼트와는 다르게 원형을 보존한다.
	* 패킷 ( packet )
		- 실제로 네트워크 구간에서 전송되어지는 형태.
		- 조각난 데이터의 일부분들과 통신 목적에 사용되는 각종 헤더 정보를 포함.
	* 소켓 버퍼
		- 수신버퍼 ( receive buffer ) 와 송신버퍼 ( send buffer ) 로 이루어져 있다.
		- TCP, UDP 모두 버퍼를 가지고 있다.
	* 단편화와 재조합
		- 데이터 전체를 통째로 보낸다면, 중간에 조그만한 오류로 인해서 데이터가 깨진 경우에
		전체를 재전송해야 한다.
			- 데이터를 잘게쪼개 일련의 번호를 부여하여 보낸다.
		- 데이터를 잘게 쪼개는 과정을 단편화 라고 하며, 
		 상대편에서 전송되어진 뒤 다시 조립되는 과정을 재조합 ( reassembly ) 이라 한다.
	* MTU ( Maximum Transfer Unit ) 
		- 데이터링크 계층에서 주고받는 데이터그램의 최대 단위.
		- 이 값보다 큰 데이터는 쪼개어지게 되며 목적지에서 다시 재조합이 발생할 수밖에 없다.
		- 데이터를 전송하려는 두 호스트 사이에 존재하는 수 많은 네트워크를 지날 때 항상 가장 작은 MTU 에 영향을 받는다.
			- 이 경로 상의 가장 작은 MTU 를 path MTU 라고 한다.
		- 트랜스포트 계층인 TCP UDP 프로토콜은 데이터링크 계층보다 상위 계층이므로 MTU 에 영향을 받는다.
		- TCP 는 단편화가 발생하기 이전에 미리 세그먼트화를 하기 때문에 단편화는 UDP 에서만 발생한다.
	* IP 헤더 용어
		* DF ( Don`t Fragment ) Flag
			- 단편화 작업을 하지 않으라는 플래그
			- 패킷의 크기보다 MTU 가 작은 구간을 만나면 더 이상 전송되지 못하고 패킷이 버려진다.
		* MF ( More Fragmentation ) Flag
			- 추가적인 단편화된 서브패킷이 존재함을 나타낸다.
		* TTL ( Time To Live )
			- 네트워크 상에서 패킷의 수명
			- 한 개의 노드를 지날때마다 1씩 감소되어진다.
			- 너무 많은 패킷이 오랫동안 살아서 네트워크를 어지럽히는 것을 방지.
	* TCP 프름제어
		- 송신 측과 수신 측의 데이터 처리 속도 차이를 해결하기 위한 기법.
		- 수신 측에서 수신된 데이터를 처리해서 상위 계층으로 서비스 하는 속도보다
		송신 측에서 보내는 데이터의 속도가 더 빠르다면 수신 측에서는 제한된 저장용량을 초과하여
		이후에 도착하는 데이터는 손실될 수 있다.
		- 이러한 위험을 줄이기 위해 송신 측의 데이터 전송 량을 수신 측에 따라 조절하는 방법.
	
		* 정지대기방식 ( Stop and Wait )
			- 송신측에서 1개의 프레임을 송신하고, 수신측에서 수신된 프레임의 에러 유무를 판단하여 송신층에 ACK 나 NAK 를 보내는 방식
			- 송신측은 수신측으로 ACK 를 수신했을 경우에만 다음 프레임을 전송.
			- 수신측으로부터 NAK 를 수신하거나, 일정시간까지 응답프레임을 수신하지 못하면 해당 프레임을 재전송
		- 장점
				- 구현이 단순
				- 송신측내에 최대 프레임 크기의 버퍼를 1개만 잡아도 됨
			- 단점
				- 송신측이 ACK 를 수신할 때까지 다음 프레임을 전송할 수 없으므로 전송효율이 떨어짐
		* 슬라이딩 윈도우 ( Sliding window )
			- 두 개의 네트워크 호스트간의 패킷의 흐름을 제어하기 위한 방법.
			- 일정한 윈도우 크기 이내에서 한번에 여러 패킷을 송신하고, 이들 패킷에 대하여 단지 한 번의 ACK 로써 수신 확인을 한다.
			- 윈도 ( 메모리 버퍼의 일정 영역 ) 에 포함되는 모든 패킷을 전송하고,
	그 패킷들이 전달이 확인되는대로 이 윈도를 옆으로 옮김 ( slide ) 으로서 그 다음 패킷들을 전송하는 방식.
			- ![Sliding window]( http://cfile214.uf.daum.net/image/162B454650EB87FA1285A9 ) 
				- 출처 http://blog.daum.net/tlos6733/48



## TCP, UDP 소켓과 IP 계층으로의 데이터 전송 시나리오
* 전송 시나리오
	1. send(2), sendto(2), write(2) 등의 쓰기 요청이 있는 경우에 소켓이 송신 버퍼로 데이터는 복사된다.
	2. TCP 의 경우 소켓 계층에서 복사된 데이터는 MTU의 크기에 맞춰서 미리 세그먼트화를 하게 되고 IP 계층으로 전송한다.
		- MSS ( Maximum Segment Size ) 에 맞춰진다.
		- MSS 는 MTU 보다 작으므로 IP 계층에서 다시 단편화되는 일은 없을 것이다.
	2. UDP 인 경우에는 그대로 IP 계층으로 전송한다.
	3. MTU 크기와 전송을 요청한 데이터의 크기를 비교하여 MTU 보다 큰 경우 MTU 크기로 단편화 한다.
		- UDP 인 경우 MTU 보다 큰 데이터는 여기서 단편화 되고 데이터링크 계층으로 내려간다..
		- TCP 는 IP 헤더만 붙여 데이터링크 계층으로 내려간다.
	4. 데이터링크계층은 네트워크 인터페이스가 직접 관장하는 계층으로, MTU 크기에 맞는지 다시 검사한 후, 
	디바이스 출력 대기열에 패킷으로 포장하여 등록을 해두고 네트워크로 패킷을 보낸다.
	5. 목적지 호스트가 먼 곳이면 WAN 으로 나가기 위해 게이트웨이를 거치게 된다.
		- 이 후로는 몇 개의 라우터를 거치면서 패킷들은 수신처러 또난다.
	6. 수신처의 LAN 에 도착하면 송신처에서 했던 과정을 역으로 거치게 된다.
		- 단편화되었을 경우 재조합이 발생.
	7. TCP 의 경우 원래의 세그먼트로 순서를 맞추고 나서 수신 버퍼로 전송
		- 세그먼트순서는 송신처에서 MSS로 잘라진 순서일 뿐이므로, 
		응용 프로그램에서 기록한 데이터의 경계는 보존되있지 않다.
		- 응용 프로그램 계층에서 사용하는 각 데이터들의 레코드 경계는 프로그래머가 구현해야 한다.
	7. UDP 의 경우 수신 대기열에서 원래 송신처에서 단편화 되기 전의 데이터그램으로 
	재조합을 거쳐 완전한 데이터그램이 완성되면 수신 버퍼로 전송.
	8. 수신측 응용 프로그램이 읽기 요청을 하게 되면 TCP 는 스트림으로서 처리되어 읽혀지고,
	UDP 는 송신처에서 보냈는 데이터그램 단위대로 읽혀지게 된다.
	
	- TCP, UDP의 IP 계층으로의 전송 ( 출처 : Linux System & Network Programming )
		- ![TCP-UDP]( https://github.com/martinkang/MyText/blob/master/LinuxNetworkProgramming/img/tcpudp.jpg )


### TCP 스트림 통신
	- TCP 는 스트림 통신이며, 데이터의 경계를 보존하지 않는다.
	- 스트림이기 때문에 연결이 필요하며, 신뢰성을 보장받는다.
		- 연결되있기 때문에 송/수신 상태 확인 및 재전송이 가능해진다.
	- 스트림의 특성 때문에 데이터의 시작과 끝을 알 수 있는 구분자 ( separator ) 를 사용하거나
	혹은 응용 프로그램의 통신용 헤더를 구성하여 
	읽어 들어야 하는 데이터의 크기를 알아내느 방법을 사용해야 한다.
	- ![TCP-UDP]( https://github.com/martinkang/MyText/blob/master/LinuxNetworkProgramming/img/tcpstreams.jpg )


### UDP 오버플로우
	- 연결이 없다는 장점 덕분에 1:1 통신이 아닌, 
	한 번의 전송으로 복수 개의 호스트에 데이터그램을 보낼 수 있다.
		- 브로드캐스팅 또는 멀티 캐스팅이라고 한다.
	- 수신측 해당 포트가 열려있지 않아도 데이터가 송신되는 경우에 데이터그램은 수신측에서 버려진다.
	- UDP 는 소켓 버퍼의 영향을 많이 받는다.
		- 응용프로그램이 보내고자 하는 최대 크기의 유저 데이터그램이 버퍼 크기보다 작아야 한다.
			- 수신 버퍼가 작은 경우 항상 실패하고, 송신버퍼가 작은 경우는 OS 마다 다르다.
		- 만약 데이터그램이 수신 버퍼 크기보다 크면, 수신 버퍼가 오버플로우가 되어 버려지게 된다.
			- netstat -s 에 UDP 오버 플로우로 검사할 수 있다.
			- UDP 유실이 심한 경우에 어떤 UDP 프로그램이 오버플로우를 일으키는지 확인하여
			수신 버퍼를 늘리거나 처리할 데이터를 세분화 하여 여러 개의 프로세스로 분산시켜 주는게 좋다.
	- UDP 데이터 그램은 작은 것이 좋다.
		- 위와 같이 에러 처리가 되지 않으므로 ( 소실된다. ) 단편화된 조각들 중 하나라도 유실되면
		데이터그램은 대기열에서 삭제되므로 수신처에는 마치 전송이 안된 것처럼 보인다.
