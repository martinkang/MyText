# C10K

## C10K 문제 
* 클라이언트 ( Client ) 가 10K( 1만 ) 개의 클라리언트에 대한 응답 속도와
시스템 부화에 관련된 문제를 다루는 것.
* 실제로 C10K 를 가능하게 하기 위해서는 fork(2) 를 통한 서버 프로세스의 복제 및
다양한 I/O 멀티플렉싱 기법들이 테스트 되었다.
	- 실제로 C10K 에 있어서 성능 상의 가장 걸림돌이 되는 것은 I/O 입출력 속도보다
	반응 속도였다.
	- 다루는 소켓의 개수가 늘어날수록 실제 이벤트가 발생한 소켓을 찾아내는데
	얼마나 빠르게 반응하느냐가 관건.


### select/poll 은 왜 epoll/kqueue 보다 느릴까?
* select 와 poll 은 옛날에 개발된 API 로 당시에는 동시 접속이 많은 I/O 입출력 처리의 기준은
기껏해야 몇 백 개의 수준이였음.
* 당시에 메모리 가격이 비쌌기 때문에 메로리를 최대한 아껴서 프로그램을 하는 것이 주된 목표였으므로
대부분의 함수들은 커널 내부에 메모리를 소모하지 않아야 했음.
	- 따라서 select 함수는 커널 내부의 메모리를 희생하지 않는 쪽으로 방향을 두다 보니
	커널 내부에 상태를 저장하지 않는( stateless ) API 로 만들어짐
	- 이로인해 select/poll 은 커널 내부에 감시 대상인 파일 기술자 정보 리스트를 보관하지 않게 됨.
		-  따라서 매번 함수 호출이 있을 때마다 파일 기술자 정보 리스트를 갱신해야 하여,
		파일 기술자 정보 리스트 중에 이벤트가 발생한 리스트를 사용자 측에서 매번 계산을 통해서 찾아야함
* 위와 같은 이유로 select/poll 은 stateless API 롯 함수 호출이 있을 때마다 커널 영역과 유저 영역 사이에
모든 파일 기술자 정보 리스트와 부가적인 정보를 복사하는 오버헤드가 있음.
- 이를 해결하기 위해 메모리 소비를 하더라도 성능 향상을 위해서 커널 내부에 따로 파일 기술자 정보 리스트와
부가적인 정보를 관리하는 영역을 만들어 두는 stateful API 가 등장함
	- kqueue 와 epoll 과 같은 기법

## 링크
* C10K problems URL : http://www.kegel.com/c10k.html
