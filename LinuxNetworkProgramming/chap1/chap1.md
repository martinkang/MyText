#1. Process

## 전통적인 프로세스 복제 방법

* fork 
	* 자식은 부모 프로세스의 복사본이며, 코드(텍스트) 세그먼트는 복사하지 않고 공유한다.
	* 자식과 부모는 메모리 영역을 공유하지 않고 복사한다.
	* 부모와 자식중 누가 먼저 실행될 지 모른다.
	* Copy on write ( COW )
		- 부모와 자식이 모든 영역을 공유하고 있다가 서로 메모리 이미지가 달라지는 시점에서 부분만 복사하는 것 
		( 복사의 단위는 page )
	- 용어
		* parent process
			- 복제할 원본 프로세스
		* child process
			- 새로이 복제된 프로세스
	* 장점
		- 멀티태스킹 : 복제된 자식 프로세스는 부모 프로세스와 독립적으로 작동
	* 단점
		- 복제된 프로레스 사이에 데이터를 주고받는 구조이고, 데이터 통신 처리에 드는 비용이 크다면 성능 하락이 일어날 수 있다.

* vfork
	* fork 후에 곧바로 exec 계열 함수를 호출하는 경우가 있는데 이 때 모든 메모리가 복사되었다가
	해제되므로 무겁다는 단점을 해결하기 위해 사용하였다.
	* 부모 프로세스와 자식 프로세스가 모든 것을 공유한다.
	* 자식부터 실행이 되는 것을 보장한다.


* system(3)
	- 쉘(sh) 를 실행시켜서 프로그램을 실행
	- 명령어가 실행되는 동안 함수는 블록되어지며, 이외에 SIGCHLD 시그널은 블록, SIGINT, SIGQUIT 시그널은 무시되어진다.
	- system(3) 은 이런 시그널이 블록킹 되어 외부에서 종료할 수 없게 되므로 종종 프로세스를 종료시킬 수 없다는 단점이 있다.



#2. 파일처리

* 저수준 파일 핸들링
	- 파일 기술자 ( file descriptor ) 를 가지고 입출력
	- 오버헤드가 적고, 버퍼링이 되지 않는다.
	- PIPE_BUF (대게 4-64KB) 이내의 길이에 대해서 원자적 실행을 보장
		- PIPE_BUF 크기는 linux/limits.h 에 선언됨
		- PIPE_BUF 크기는 파일 기술자를 통한 입출력 함수들이 원자적 실행을 보장하는 길이.
	- 비직관적

* 고수준 파일 핸들링
	- 파일 포인터 ( 스트림 ) 을 이용하여 입출력하는 방식으로 FILE * 를 사용
	- 버퍼링 가능
	- 원하는 형태로 포매팅 가능
	- 버퍼링의 경우 플러시 되는 시점에 따라서 원자적 실행을 보장할 수 없다.
		- 멀티 쓰레드나 시그널 핸들러 사용 시 데이터 출력이 서로 섞이거나 출력되지 않는 경우가 있다.
